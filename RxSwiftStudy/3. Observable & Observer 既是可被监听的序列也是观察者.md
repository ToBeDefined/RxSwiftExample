## Observable & Observer 既是可被监听的序列也是观察者

[https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer.html](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer.html)


在我们所遇到的事物中，有一部分非常特别。它们既是**可被监听的序列**也是**观察者**。

例如：`textField`的当前文本。它可以看成是由用户输入，而产生的一个**文本序列**。也可以是由外部文本序列，来控制当前显示内容的**观察者**：

```swift
// 作为可被监听的序列
let observable = textField.rx.text
observable.subscribe(onNext: { text in show(text: text) })
```

```swift
// 作为观察者
let observer = textField.rx.text
let text: Observable<String?> = ...
text.bind(to: observer)
```

看下 `textField`的 `rx.text` 的定义

```swift
public var text: ControlProperty<String?> {
    return value
}
    
/// Reactive wrapper for `text` property.
public var value: ControlProperty<String?> {
    return base.rx.controlPropertyWithDefaultEvents(
        getter: { textField in
            textField.text
        },
        setter: { textField, value in
            // This check is important because setting text value always clears control state
            // including marked text selection which is imporant for proper input 
            // when IME input method is used.
            if textField.text != value {
                textField.text = value
            }
        }
    )
}
```

看下 `ControlProperty<Element>` 是啥

```swift

public protocol ControlPropertyType : ObservableType, ObserverType {
    ...
}

public struct ControlProperty<PropertyType> : ControlPropertyType {
    ...
    ...
}
```


有许多 UI 控件都存在这种特性，例如：`switch`的开关状态，`segmentedControl`的选中索引号，`datePicker`的选中日期等等。

另外，框架里面定义了一些辅助类型，它们既是**可被监听的序列**也是**观察者**。如果你能合适的应用这些辅助类型，它们就可以帮助你更准确的描述事物的特征。


## AsyncSubject

[https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/async_subject.html](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/async_subject.html)

```swift
public final class AsyncSubject<Element>
    : Observable<Element>
    , SubjectType
    , ObserverType
    , SynchronizedUnsubscribeType {
    ...
    ...
}
```

- 如果源 `Observable`在发出多个元素并产生完成事件后， **AsyncSubject** 发出最后一个元素（仅仅只有最后一个元素）；
- 如果源 `Observable` 没有发出任何元素，只有一个完成事件， **AsyncSubject** 也只有一个完成事件。
- 如果源 `Observable` 因为产生了一个 `error` 事件而中止， **AsyncSubject** 就不会发出任何元素，而是将这个 `error` 事件发送出来。

eg:

```swift
private let disposeBag = DisposeBag()
func testAsyncSubject() {
    let subject = AsyncSubject<String>()
    
    subject.subscribe({ (e) in
        print("Subscription: 1 Event:", e)
    }).disposed(by: disposeBag)
    
    // 1
    subject.onNext("🐶")
    subject.onNext("🐱")
    // 只发送 onCompleted前面最后一个
    subject.onNext("🐹")
    subject.onCompleted()
}
```

输出如下：

```swift
Subscription: 1 Event: next(🐹)
Subscription: 1 Event: completed
```


## PublishSubject

[https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/publish_subject.html](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/publish_subject.html)

```swift
public final class PublishSubject<Element>
    : Observable<Element>
    , SubjectType
    , Cancelable
    , ObserverType
    , SynchronizedUnsubscribeType {
    ...
    ...
}
```

**PublishSubject** 将对观察者发送订阅后产生的元素，而在订阅前发出的元素将不会发送给观察者。

如果你希望观察者接收到所有的元素，你可以通过使用 `Observable` 的 `create` 方法来创建 `Observable`，或者使用 **ReplaySubject**。


- 如果源 `Observable`在发出多个元素并产生完成事件后， **PublishSubject** 发出最后一个元素（仅仅只有最后一个元素）；
- 如果源 `Observable` 没有发出任何元素，只有一个完成事件， **PublishSubject** 也只有一个完成事件。
- 如果源 `Observable` 因为产生了一个 `error` 事件而中止， **PublishSubject** 就不会发出任何元素，而是将这个 `error` 事件发送出来。


```swift
func testPublishSubject() {
    let disposeBag = DisposeBag()
    let subject = PublishSubject<String>()
    
    subject.subscribe({ (e) in
        print("Subscription: 1 Event:", e)
    }).disposed(by: disposeBag)
    
    subject.onNext("🐶")
    subject.onNext("🐱")
    
    subject.subscribe({ (e) in
        print("Subscription: 2 Event:", e)
    }).disposed(by: disposeBag)
    
    subject.onNext("🅰️")
    subject.onNext("🅱️")
    subject.onCompleted()
}
```

输出如下：

```swift
Subscription: 1 Event: next(🐶)
Subscription: 1 Event: next(🐱)
Subscription: 1 Event: next(🅰️)
Subscription: 2 Event: next(🅰️)
Subscription: 1 Event: next(🅱️)
Subscription: 2 Event: next(🅱️)
Subscription: 1 Event: completed
Subscription: 2 Event: completed
```




