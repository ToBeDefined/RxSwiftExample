
## Operator - 操作符

> [官方文档 http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)

> [中文翻译文档 https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html)

### [Debug](./Operator/Debug.md)

- debug

- do

### [创建 Observable](./Operator/Create_Observable.md)

- create

- never

- empty

- just

- error

- from

- of

- range

- repeatElement

- defer

- interval

- timer

### [变换 Observable](./Operator/Transforming.md)

- toArray

- map

- scan

- flatMap

- flatMapFirst

- flatMapLatest

- flatMapWithIndex

- concatMap

- buffer

- window

- groupBy

### [过滤 Observable](./Operator/Filtering.md)

- ignoreElements

- elementAt

- filter

- debounce

- throttle

- distinctUntilChanged

- sample

- skip

- skipWhile

- skipUntil

- take

- takeLast

- takeWhile

- takeUntil

- single

### [联合 Observable](./Operator/Combining.md)

- startWith

- combineLatest

- zip

- withLatestFrom

- merge

- switchLatest

### [错误处理操作符](./Operator/ErrorHandling.md)

- catchError

- catchErrorJustReturn

- retry

- retryWhen

### [条件和 Bool 操作符](./Operator/Conditional_and_Boolean.md)

- amb

- skipWhile

- skipUntil

- takeWhile

- takeUntil

### [数学和聚合操作符](./Operator/Mathematical_and_Aggregate.md)

- concat

- reduce

### [连接 Observable 操作符](./Operator/Connectable.md)

- multicast

- publish

- connect

- refCount

- replay

- share

- shareReplay

- shareReplayLatestWhileConnected

### [About Time](./Operator/Time.md)

- delay

- delaySubscription

- defer

- interval

- timer

- timeout

### [Scheduler](./Operator/Scheduler.md)

- observeOn

- subscribeOn

### [Materialize](./Operator/Materialize.md)

- materialize

- dematerialize

### [Using](./Operator/Using.md)

- using


## 准备测试使用的方法

```swift
func getFirstObservable() -> Observable<String> {
    return Observable<String>.create({ (observer) -> Disposable in
        // section 1
        delayTime(1, block: {
            observer.onNext("First -> 1|A")
            observer.onNext("First -> 1|B")
            observer.onNext("First -> 1|C")
        })
        
        // section 2
        delayTime(5, block: {
            observer.onNext("First -> 2|A")
            observer.onNext("First -> 2|B")
            observer.onNext("First -> 2|C")
        })
        
        // section 3
        delayTime(9, block: {
            observer.onNext("First -> 3|A")
            observer.onNext("First -> 3|B")
            observer.onNext("First -> 3|C")
            observer.onCompleted()
        })
        return Disposables.create()
    })
}
    
func getSecondObservable() -> Observable<String> {
    return Observable<String>.create({ (observer) -> Disposable in
        delayTime(0.1, block: {
            observer.onNext("Second -> 1")
            
            delayTime(4, block: {
                observer.onNext("Second -> 2")
            })
            
            delayTime(8, block: {
                observer.onNext("Second -> 3")
                observer.onCompleted()
            })
        })
        return Disposables.create()
    })
}
    
func getThirdObservable() -> Observable<String> {
    return Observable<String>.create({ (observer) -> Disposable in
        delayTime(0.1, block: {
            observer.onNext("Third -> 1")
            observer.onNext("Third -> 2")
            observer.onNext("Third -> 3")
            observer.onCompleted()
        })
        return Disposables.create()
    })
}
    
func getFourthObservable() -> Observable<String> {
    let observable = Observable<String>.create({ (observer) -> Disposable in
        print("> Send onNext(\"0️⃣\")")
        observer.onNext("0️⃣")
        
        delayTime(1, block: {
            print("> Send onNext(\"1️⃣\")")
            observer.onNext("1️⃣")
        })
        
        delayTime(2, block: {
            print("> Send onNext(\"2️⃣\")")
            observer.onNext("2️⃣")
        })
        return Disposables.create()
    })
    return observable
}
    
func getErrorObservable() -> Observable<String> {
    return Observable<String>.create({ (observer) -> Disposable in
        delayTime(1, block: {
            observer.onNext("1️⃣")
        })
        delayTime(2, block: {
            observer.onNext("2️⃣")
        })
        delayTime(3, block: {
            let err = TError.init(errorCode: 10, errorString: "Test", errorData: nil)
            observer.onError(err)
        })
        return Disposables.create()
    })
}
```


