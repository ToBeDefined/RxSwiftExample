## Observable & Observer - æ—¢æ˜¯å¯è¢«ç›‘å¬çš„åºåˆ—ä¹Ÿæ˜¯è§‚å¯Ÿè€…

[https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer.html](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer.html)


åœ¨æˆ‘ä»¬æ‰€é‡åˆ°çš„äº‹ç‰©ä¸­ï¼Œæœ‰ä¸€éƒ¨åˆ†éå¸¸ç‰¹åˆ«ã€‚å®ƒä»¬æ—¢æ˜¯**å¯è¢«ç›‘å¬çš„åºåˆ—**ä¹Ÿæ˜¯**è§‚å¯Ÿè€…**ã€‚

ä¾‹å¦‚ï¼š`textField`çš„å½“å‰æ–‡æœ¬ã€‚å®ƒå¯ä»¥çœ‹æˆæ˜¯ç”±ç”¨æˆ·è¾“å…¥ï¼Œè€Œäº§ç”Ÿçš„ä¸€ä¸ª**æ–‡æœ¬åºåˆ—**ã€‚ä¹Ÿå¯ä»¥æ˜¯ç”±å¤–éƒ¨æ–‡æœ¬åºåˆ—ï¼Œæ¥æ§åˆ¶å½“å‰æ˜¾ç¤ºå†…å®¹çš„**è§‚å¯Ÿè€…**ï¼š

```swift
// ä½œä¸ºå¯è¢«ç›‘å¬çš„åºåˆ—
let observable = textField.rx.text
observable.subscribe(onNext: { text in show(text: text) })
```

```swift
// ä½œä¸ºè§‚å¯Ÿè€…
let observer = textField.rx.text
let text: Observable<String?> = ...
text.bind(to: observer)
```

çœ‹ä¸‹ `textField`çš„ `rx.text` çš„å®šä¹‰

```swift
public var text: ControlProperty<String?> {
    return value
}
    
/// Reactive wrapper for `text` property.
public var value: ControlProperty<String?> {
    return base.rx.controlPropertyWithDefaultEvents(
        getter: { textField in
            textField.text
        },
        setter: { textField, value in
            // This check is important because setting text value always clears control state
            // including marked text selection which is imporant for proper input 
            // when IME input method is used.
            if textField.text != value {
                textField.text = value
            }
        }
    )
}
```

çœ‹ä¸‹ `ControlProperty<Element>` æ˜¯å•¥

```swift

public protocol ControlPropertyType : ObservableType, ObserverType {
    ...
}

public struct ControlProperty<PropertyType> : ControlPropertyType {
    ...
    ...
}
```


æœ‰è®¸å¤š UI æ§ä»¶éƒ½å­˜åœ¨è¿™ç§ç‰¹æ€§ï¼Œä¾‹å¦‚ï¼š`switch`çš„å¼€å…³çŠ¶æ€ï¼Œ`segmentedControl`çš„é€‰ä¸­ç´¢å¼•å·ï¼Œ`datePicker`çš„é€‰ä¸­æ—¥æœŸç­‰ç­‰ã€‚

å¦å¤–ï¼Œæ¡†æ¶é‡Œé¢å®šä¹‰äº†ä¸€äº›è¾…åŠ©ç±»å‹ï¼Œå®ƒä»¬æ—¢æ˜¯**å¯è¢«ç›‘å¬çš„åºåˆ—**ä¹Ÿæ˜¯**è§‚å¯Ÿè€…**ã€‚å¦‚æœä½ èƒ½åˆé€‚çš„åº”ç”¨è¿™äº›è¾…åŠ©ç±»å‹ï¼Œå®ƒä»¬å°±å¯ä»¥å¸®åŠ©ä½ æ›´å‡†ç¡®çš„æè¿°äº‹ç‰©çš„ç‰¹å¾ã€‚

## AsyncSubject

[https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/async_subject.html](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/async_subject.html)

```swift
public final class AsyncSubject<Element>
    : Observable<Element>
    , SubjectType
    , ObserverType
    , SynchronizedUnsubscribeType {
    ...
    ...
}
```

- å¦‚æœæº `Observable`åœ¨å‘å‡ºå¤šä¸ªå…ƒç´ å¹¶äº§ç”Ÿå®Œæˆäº‹ä»¶åï¼Œ **AsyncSubject** å‘å‡ºæœ€åä¸€ä¸ªå…ƒç´ ï¼ˆä»…ä»…åªæœ‰æœ€åä¸€ä¸ªå…ƒç´ ï¼‰ï¼›
- å¦‚æœæº `Observable` æ²¡æœ‰å‘å‡ºä»»ä½•å…ƒç´ ï¼Œåªæœ‰ä¸€ä¸ªå®Œæˆäº‹ä»¶ï¼Œ **AsyncSubject** ä¹Ÿåªæœ‰ä¸€ä¸ªå®Œæˆäº‹ä»¶ã€‚
- å¦‚æœæº `Observable` å› ä¸ºäº§ç”Ÿäº†ä¸€ä¸ª `error` äº‹ä»¶è€Œä¸­æ­¢ï¼Œ **AsyncSubject** å°±ä¸ä¼šå‘å‡ºä»»ä½•å…ƒç´ ï¼Œè€Œæ˜¯å°†è¿™ä¸ª `error` äº‹ä»¶å‘é€å‡ºæ¥ã€‚

åˆ›å»ºæ–¹æ³•ï¼š

```
let subject = AsyncSubject<String>()
```

egï¼š

```swift
func testAsyncSubject() {
    let subject = AsyncSubject<String>()
    
    subject
        .subscribe({ (e) in
            print("Subscription: 1 Event:", e)
        })
        .disposed(by: disposeBag)
    // 1
    subject.onNext("ğŸ¶")
    subject.onNext("ğŸ±")
    // åªå‘é€ onCompletedå‰é¢æœ€åä¸€ä¸ª
    subject.onNext("ğŸ¹")
    subject.onCompleted()
}
```

è¾“å‡ºå¦‚ä¸‹ï¼š

```swift
Subscription: 1 Event: next(ğŸ¹)
Subscription: 1 Event: completed
```


## PublishSubject

[https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/publish_subject.html](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/publish_subject.html)

```swift
public final class PublishSubject<Element>
    : Observable<Element>
    , SubjectType
    , Cancelable
    , ObserverType
    , SynchronizedUnsubscribeType {
    ...
    ...
}
```

- å¯¹è§‚å¯Ÿè€…å‘é€è®¢é˜…åäº§ç”Ÿçš„å…ƒç´ 
- åœ¨è§‚å¯Ÿè€…è®¢é˜…å‰å‘å‡ºçš„å…ƒç´ ä¸ä¼šé‡æ–°å‘é€ç»™è§‚å¯Ÿè€…ï¼ˆåªä¼šå‘é€è®¢é˜…ä¹‹åäº§ç”Ÿçš„å…ƒç´ ç»™è¿™ä¸ªè®¢é˜…è€…ï¼‰

> å¦‚æœä½ å¸Œæœ›è§‚å¯Ÿè€…æ¥æ”¶åˆ°æ‰€æœ‰çš„å…ƒç´ ï¼Œä½ å¯ä»¥é€šè¿‡ä½¿ç”¨ `Observable` çš„ `create` æ–¹æ³•æ¥åˆ›å»º `Observable`ï¼Œæˆ–è€…ä½¿ç”¨ **ReplaySubject**ã€‚

åˆ›å»ºæ–¹æ³•ï¼š

```swift
let subject = PublishSubject<String>()
```

egï¼š

```swift
func testPublishSubject() {
    let disposeBag = DisposeBag()
    let subject = PublishSubject<String>()
    
    subject
        .subscribe({ (e) in
            print("Subscription: 1 Event:", e)
        })
        .disposed(by: disposeBag)
    
    subject.onNext("ğŸ¶")
    subject.onNext("ğŸ±")
    
    subject
        .subscribe({ (e) in
            print("Subscription: 2 Event:", e)
        })
        .disposed(by: disposeBag)
    
    subject.onNext("ğŸ…°ï¸")
    subject.onNext("ğŸ…±ï¸")
    subject.onCompleted()
}
```

è¾“å‡ºå¦‚ä¸‹ï¼š

```swift
Subscription: 1 Event: next(ğŸ¶)
Subscription: 1 Event: next(ğŸ±)
Subscription: 1 Event: next(ğŸ…°ï¸)
Subscription: 2 Event: next(ğŸ…°ï¸)
Subscription: 1 Event: next(ğŸ…±ï¸)
Subscription: 2 Event: next(ğŸ…±ï¸)
Subscription: 1 Event: completed
Subscription: 2 Event: completed
```


## ReplaySubject

[https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/replay_subject.html](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/replay_subject.html)

```swift
public class ReplaySubject<Element>
    : Observable<Element>
    , SubjectType
    , ObserverType
    , Disposable {
    ...
    ...
}
```

- å¯¹è§‚å¯Ÿè€…å‘é€å…¨éƒ¨çš„å…ƒç´ ï¼Œæ— è®ºè§‚å¯Ÿè€…æ˜¯ä½•æ—¶è¿›è¡Œè®¢é˜…çš„ã€‚ä¼šæŒ‰é¡ºåºè¡¥å‘è®¢é˜…ä¹‹å‰äº§ç”Ÿçš„å…ƒç´ 
- è¿™é‡Œå­˜åœ¨å¤šä¸ªç‰ˆæœ¬çš„ **ReplaySubject**ï¼Œæœ‰çš„åªä¼šå°†æœ€æ–°çš„ n ä¸ªå…ƒç´ å‘é€ç»™è§‚å¯Ÿè€…ï¼Œæœ‰çš„åªä¼šå°†é™åˆ¶æ—¶é—´æ®µå†…æœ€æ–°çš„å…ƒç´ å‘é€ç»™è§‚å¯Ÿè€…ã€‚
- å¦‚æœæŠŠ **ReplaySubject** å½“ä½œè§‚å¯Ÿè€…æ¥ä½¿ç”¨ï¼Œæ³¨æ„ä¸è¦åœ¨å¤šä¸ªçº¿ç¨‹è°ƒç”¨ `onNext`, `onError` æˆ– `onCompleted`ã€‚è¿™æ ·ä¼šå¯¼è‡´æ— åºè°ƒç”¨ï¼Œå°†é€ æˆæ„æƒ³ä¸åˆ°çš„ç»“æœã€‚

åˆ›å»ºæ–¹æ³•ï¼š

```swift
// ç¼“å­˜æ‰€æœ‰å·²äº§ç”Ÿçš„å…ƒç´ 
let subject = ReplaySubject<String>.createUnbounded()
// ç¼“å­˜æŒ‡å®šæ•°é‡çš„å·²äº§ç”Ÿçš„å…ƒç´ 
let subject = ReplaySubject<String>.create(bufferSize: 1)

```

egï¼š

```swift
func testReplaySubject() {
    // let subject = ReplaySubject<String>.createUnbounded()
    let subject = ReplaySubject<String>.create(bufferSize: 1)
    
    subject
        .subscribe { print("Subscription: 1 Event:", $0) }
        .disposed(by: disposeBag)
    
    subject.onNext("ğŸ¶")
    subject.onNext("ğŸ±")
    
    subject
        .subscribe { print("Subscription: 2 Event:", $0) }
        .disposed(by: disposeBag)
    
    subject.onNext("ğŸ…°ï¸")
    subject.onNext("ğŸ…±ï¸")
}
```

è¾“å‡ºå¦‚ä¸‹ï¼š

```swift
Subscription: 1 Event: next(ğŸ¶)
Subscription: 1 Event: next(ğŸ±)
Subscription: 2 Event: next(ğŸ±)
Subscription: 1 Event: next(ğŸ…°ï¸)
Subscription: 2 Event: next(ğŸ…°ï¸)
Subscription: 1 Event: next(ğŸ…±ï¸)
Subscription: 2 Event: next(ğŸ…±ï¸)
```

## BehaviorSubject

[https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/behavior_subject.html](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/behavior_subject.html)

```swift
public final class BehaviorSubject<Element>
    : Observable<Element>
    , SubjectType
    , ObserverType
    , SynchronizedUnsubscribeType
    , Disposable {
    ...
    ...
}
```


- å½“è§‚å¯Ÿè€…å¯¹ **BehaviorSubject** è¿›è¡Œè®¢é˜…æ—¶ï¼Œå®ƒä¼šå°†æº `Observable` ä¸­æœ€æ–°çš„å…ƒç´ å‘é€å‡ºæ¥
- å¦‚æœä¸å­˜åœ¨æœ€æ–°çš„å…ƒç´ ï¼Œå°±å‘å‡ºé»˜è®¤å…ƒç´ ã€‚
- æ¯å½“äº§ç”Ÿæ–°çš„å…ƒç´ ï¼Œéƒ½ä¼šå‘é€ç»™è§‚å¯Ÿè€…ã€‚
- å¦‚æœæº `Observable` å› ä¸ºäº§ç”Ÿäº†ä¸€ä¸ª `error` äº‹ä»¶è€Œä¸­æ­¢ï¼Œ **BehaviorSubject** å°±ä¸ä¼šå‘å‡ºä»»ä½•å…ƒç´ ï¼Œè€Œæ˜¯å°†è¿™ä¸ª `error` äº‹ä»¶å‘é€å‡ºæ¥ã€‚


egï¼š

```swift
func testBehaviorSubject() {
    let subject = BehaviorSubject(value: "ğŸ”´")
    
    subject
        .subscribe { print("Subscription: 1 Event:", $0) }
        .disposed(by: disposeBag)
    
    subject.onNext("ğŸ¶")
    subject.onNext("ğŸ±")
    
    subject
        .subscribe { print("Subscription: 2 Event:", $0) }
        .disposed(by: disposeBag)
    
    subject.onNext("ğŸ…°ï¸")
    subject.onNext("ğŸ…±ï¸")
    
    subject
        .subscribe { print("Subscription: 3 Event:", $0) }
        .disposed(by: disposeBag)
    
    subject.onNext("ğŸ")
    subject.onNext("ğŸŠ")
}
```

è¾“å‡ºå¦‚ä¸‹ï¼š

```swift
Subscription: 1 Event: next(ğŸ”´)
Subscription: 1 Event: next(ğŸ¶)
Subscription: 1 Event: next(ğŸ±)
Subscription: 2 Event: next(ğŸ±)
Subscription: 1 Event: next(ğŸ…°ï¸)
Subscription: 2 Event: next(ğŸ…°ï¸)
Subscription: 1 Event: next(ğŸ…±ï¸)
Subscription: 2 Event: next(ğŸ…±ï¸)
Subscription: 3 Event: next(ğŸ…±ï¸)
Subscription: 1 Event: next(ğŸ)
Subscription: 2 Event: next(ğŸ)
Subscription: 3 Event: next(ğŸ)
Subscription: 1 Event: next(ğŸŠ)
Subscription: 2 Event: next(ğŸŠ)
Subscription: 3 Event: next(ğŸŠ)
```

## Variable

[https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/variable.html](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/variable.html)


```swift
public final class Variable<Element> {
    ...
    ...
}
```


åœ¨ **Swift** ä¸­æˆ‘ä»¬ç»å¸¸ä¼šç”¨ **var** å…³é”®å­—æ¥å£°æ˜å˜é‡ã€‚**RxSwift** æä¾›çš„ **Variable** å®é™…ä¸Šæ˜¯ **var** çš„ **Rx** ç‰ˆæœ¬ï¼Œä½ å¯ä»¥å°†å®ƒçœ‹ä½œæ˜¯ **RxVarã€‚**

æˆ‘ä»¬æ¥å¯¹æ¯”ä¸€ä¸‹ **var** ä»¥åŠ **Variable** çš„ç”¨æ³•ï¼š

**ä½¿ç”¨ varï¼š**

```swift
// åœ¨ ViewController ä¸­
var model: Model? = nil {
    didSet { updateUI(with: model) }
}

override func viewDidLoad() {
    super.viewDidLoad()

    model = getModel()
}

func updateUI(with model: Model?) { ... }
func getModel() -> Model { ... }
```

**ä½¿ç”¨ Variableï¼š**

```swift
// åœ¨ ViewController ä¸­
let model: Variable<Model?> = Variable(nil)

override func viewDidLoad() {
    super.viewDidLoad()

    model.asObservable()
        .subscribe(onNext: { [weak self] model in
            self?.updateUI(with: model)
        })
        .disposed(by: disposeBag)

    model.value = getModel()
}

func updateUI(with model: Model?) { ... }
func getModel() -> Model { ... }
```

ç¬¬ä¸€ç§ä½¿ç”¨ **var** çš„æ–¹å¼ååˆ†å¸¸è§ï¼Œåœ¨ `ViewController` ä¸­ç›‘å¬ `Model` çš„å˜åŒ–ï¼Œç„¶ååˆ·æ–°é¡µé¢ã€‚

ç¬¬äºŒç§ä½¿ç”¨ **Variable** åˆ™æ˜¯ **RxSwift** ç‹¬æœ‰çš„ã€‚**Variable** å‡ ä¹æä¾›äº† **var** çš„æ‰€æœ‰åŠŸèƒ½ã€‚å¦å¤–ï¼ŒåŠ ä¸Šä¸€æ¡éå¸¸é‡è¦çš„ç‰¹æ€§ï¼Œå°±æ˜¯å¯ä»¥é€šè¿‡è°ƒç”¨ `asObservable()` æ–¹æ³•è½¬æ¢æˆ**åºåˆ—**ã€‚ç„¶åä½ å¯ä»¥å¯¹è¿™ä¸ª**åºåˆ—**åº”ç”¨æ“ä½œç¬¦ï¼Œæ¥åˆæˆå…¶ä»–çš„**åºåˆ—**ã€‚æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬å£°æ˜çš„å˜é‡éœ€è¦æä¾› **Rx** æ”¯æŒï¼Œé‚£å°±é€‰ç”¨ **Variable** è¿™ä¸ªç±»å‹ã€‚


> è¯´æ˜: 
> 
> **Variable** å°è£…äº†ä¸€ä¸ª [BehaviorSubject](behavior_subject.md)ï¼Œæ‰€ä»¥å®ƒä¼šæŒæœ‰å½“å‰å€¼ï¼Œå¹¶ä¸” **Variable** ä¼šå¯¹æ–°çš„è§‚å¯Ÿè€…å‘é€å½“å‰å€¼ã€‚å®ƒä¸ä¼šäº§ç”Ÿ `error` äº‹ä»¶ã€‚**Variable** åœ¨ `deinit` æ—¶ï¼Œä¼šå‘å‡ºä¸€ä¸ª `completed` äº‹ä»¶ã€‚


eg:

```swift
func testVariable() {
    struct Model {
        var text: String?
        var image: UIImage?
    }
    
    func updateView(with model: Model?) {
        guard let m = model else { return }
        DispatchQueue.main.async {
            self.imageView.image = m.image
            print(m.text ?? "none")
        }
    }
    
    let model: Variable<Model?> = Variable.init(nil)
    
    model
        .asObservable()
        .subscribe(onNext: { (m) in
            updateView(with: m)
        })
        .disposed(by: disposeBag)
    
    getImage()
        .subscribe(onNext: { (image) in
            model.value = Model.init(text: image.description, image: image)
        }, onError: { (err) in
            if let err = err as? TError {
                err.printLog()
                return
            }
            print(err.localizedDescription)
        })
        .disposed(by: disposeBag)
}
```

## ControlProperty

[https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/control_property.html](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/control_property.html)


```swift
public protocol ControlPropertyType : ObservableType, ObserverType {

    /// - returns: `ControlProperty` interface
    func asControlProperty() -> ControlProperty<E>
}

public struct ControlProperty<PropertyType> : ControlPropertyType {
    ...
    ...
}
```

**ControlProperty** ä¸“é—¨ç”¨äºæè¿° **UI** æ§ä»¶å±æ€§çš„ï¼Œå®ƒå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

* ä¸ä¼šäº§ç”Ÿ `error` äº‹ä»¶
* ä¸€å®šåœ¨ `MainScheduler` è®¢é˜…ï¼ˆä¸»çº¿ç¨‹è®¢é˜…ï¼‰
* ä¸€å®šåœ¨ `MainScheduler` ç›‘å¬ï¼ˆä¸»çº¿ç¨‹ç›‘å¬ï¼‰
* å…±äº«çŠ¶æ€å˜åŒ–


eg:

```swift
func testControlProperty() {
    // ä»…ä»…ç”¨äºæµ‹è¯•ï¼Œä¸»è¦ç”¨äºUIæ§ä»¶ï¼Œä¾‹å¦‚ textField.rx.text
    
    // Creat:
    var c_value: String = ""
    let c_observable = Observable<String>.create({ (observer) -> Disposable in
        observer.onNext(c_value)
        observer.onCompleted()
        return Disposables.create()
    })
    let c_observer = AnyObserver<String>.init { (e) in
        switch e {
        case .next(let el):
            c_value = el
        default:
            break
        }
        print("controlProperty is Changed: " + e.debugDescription)
    }
    let controlProperty = ControlProperty<String>.init(values: c_observable, valueSink: c_observer)
    
    
    // USE:
    
    let observable = Observable<String>.create({ (observer) -> Disposable in
        observer.onNext("æµ‹è¯•1")
        observer.onNext("æµ‹è¯•2")
        observer.onCompleted()
        return Disposables.create()
    })
    
    let observer = AnyObserver<String>.init { (e) in
        print("controlProperty Value Is: " + e.debugDescription)
    }
    
    
    observable
        .bind(to: controlProperty)
        .disposed(by: disposeBag)
    
    controlProperty
        .bind(to: observer)
        .disposed(by: disposeBag)
}
```



## é™„å½•

> Subjectç›¸å…³çš„ä¸€äº› `Protocol` | `Class` | `Struct` å®šä¹‰

- `ObservableType`

```swift
public protocol ObservableConvertibleType {
    /// Type of elements in sequence.
    associatedtype E

    /// Converts `self` to `Observable` sequence.
    ///
    /// - returns: Observable sequence that represents `self`.
    func asObservable() -> Observable<E>
}

public protocol ObservableType : ObservableConvertibleType {
    /**
    Subscribes `observer` to receive events for this sequence.
    
    ### Grammar
    
    **Next\* (Error | Completed)?**
    
    * sequences can produce zero or more elements so zero or more `Next` events can be sent to `observer`
    * once an `Error` or `Completed` event is sent, the sequence terminates and can't produce any other elements
    
    It is possible that events are sent from different threads, but no two events can be sent concurrently to
    `observer`.
    
    ### Resource Management
    
    When sequence sends `Complete` or `Error` event all internal resources that compute sequence elements
    will be freed.
    
    To cancel production of sequence elements and free resources immediately, call `dispose` on returned
    subscription.
    
    - returns: Subscription for `observer` that can be used to cancel production of sequence elements and free resources.
    */
    func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E
}
```

- `Observable<Element>`

```swift
public class Observable<Element> : ObservableType {
    ...
    ...
}
```

- `SubjectType`


```swift
public protocol SubjectType : ObservableType {
    /// The type of the observer that represents this subject.
    ///
    /// Usually this type is type of subject itself, but it doesn't have to be.
    associatedtype SubjectObserverType : ObserverType

    /// Returns observer interface for subject.
    ///
    /// - returns: Observer interface for subject.
    func asObserver() -> SubjectObserverType
    
}
```

- `ObserverType`

```swift
public protocol ObserverType {
    /// The type of elements in sequence that observer can observe.
    associatedtype E

    /// Notify observer about sequence event.
    ///
    /// - parameter event: Event that occurred.
    func on(_ event: Event<E>)
}
```

- SynchronizedUnsubscribeType

```swift
protocol SynchronizedUnsubscribeType : class {
    associatedtype DisposeKey

    func synchronizedUnsubscribe(_ disposeKey: DisposeKey)
}
```

- `Disposable`

```swift
public protocol Disposable {
    /// Dispose resource.
    func dispose()
}
```
