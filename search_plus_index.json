{"./":{"url":"./","title":"Introduction","keywords":"","body":"RxSwift Example 主要是RxSwift的一些操作符的示例 部分内容摘自官方文档以及翻译的中文文档 相关地址 RxSwiftExample Xcode项目: https://github.com/ToBeDefined/RxSwiftExample/ GitBook地址: http://rxswift.tbd.ink GitBook备用地址: https://swift.rx.tbd.ink 目录 1. Observable - 可被监听的序列 2. Observer - 观察者 3. Observable & Observer 既是可被监听的序列也是观察者 4. Disposable - 可被清除的资源 5. Schedulers - 调度器 6. Error Handling - 错误处理 7. Operator - 操作符 7.00 准备测试使用的方法 7.01 Debug Operator 7.02 创建 Observable 7.03 变换 Observable 7.04 过滤 Observable 7.05 联合 Observable 7.06 错误处理操作符 7.07 条件和 Bool 操作符 7.08 数学和聚合操作符 7.09 连接 Observable 操作符 7.10 Time Operator 7.11 Scheduler Operator 7.12 Materialize Operator 7.13 Using Operator 8. 其他相关资料 "},"RxSwiftStudy/1.Observable-可被监听的序列.html":{"url":"RxSwiftStudy/1.Observable-可被监听的序列.html","title":"1. Observable - 可被监听的序列","keywords":"","body":"准备 typealias JSON = Any struct TError: Error { var errorCode: Int = 0 var errorString: String = \"\" var errorData: Any? func printLog() { print(errorCode) print(errorString) if let data = errorData as? Data { let str = String.init(data: data, encoding: String.Encoding.utf8) print(str ?? \"NULL Error Data\") } } } Observable - 可被监听的序列 https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable.html public protocol ObservableConvertibleType { ... ... } public protocol ObservableType : ObservableConvertibleType { ... ... } public class Observable : ObservableType { ... ... } 如何创建序列 现在我们已经可以把生活中的许多事物看作是一个序列了。那么我们要怎么创建这些序列呢？ 实际上，框架已经帮我们创建好了许多常用的序列。例如：button的点击，textField的当前文本，switch的开关状态，slider的当前数值等等。 另外，有一些自定义的序列是需要我们自己创建的。这里介绍一下创建序列最基本的方法，例如，我们创建一个 [0, 1, ... 8, 9] 的序列： let numbers: Observable = Observable.create { observer -> Disposable in observer.onNext(0) observer.onNext(1) observer.onNext(2) observer.onNext(3) observer.onNext(4) observer.onNext(5) observer.onNext(6) observer.onNext(7) observer.onNext(8) observer.onNext(9) observer.onCompleted() return Disposables.create() } 创建序列最直接的方法就是调用 Observable.create，然后在构建函数里面描述元素的产生过程。 observer.onNext(0) 就代表产生了一个元素，他的值是 0。后面又产生了 9 个元素分别是 1, 2, ... 8, 9 。最后，用 observer.onCompleted() 表示元素已经全部产生，没有更多元素了。 func getObservable(with url: String) -> Observable { return Observable.create { (observer) -> Disposable in guard let url = URL.init(string: url) else { let err = TError.init(errorCode: 10, errorString: \"url error\", errorData: nil) observer.onError(err) return Disposables.create() } let request = URLRequest.init(url: url) let task = URLSession.shared.dataTask(with: request, completionHandler: { (data, response, error) in if let err = error { observer.onError(err) return } guard let jsonData = data, let jsonObj = try? JSONSerialization.jsonObject(with: jsonData, options: .mutableLeaves) else { let err = TError.init(errorCode: 11, errorString: \"json error\", errorData: data) observer.onError(err) return } // 测试多个事件 // observer.onNext(1234) observer.onNext(jsonObj) observer.onCompleted() // onCompleted之后不发送 observer.onNext(2222222) observer.onCompleted() }) task.resume() return Disposables.create { task.cancel() } } } 在闭包回调中，如果任务失败，就调用 observer.onError(error!)。如果获取到目标元素，就调用 observer.onNext(jsonObject)。由于我们的这个序列只有一个元素，所以在成功获取到元素后，就直接调用 observer.onCompleted() 来表示任务结束。最后 Disposables.create { task.cancel() } 说明如果数据绑定被清除（订阅被取消）的话，就取消网络请求。 这样一来我们就将传统的闭包回调转换成序列了。然后可以用 subscribe 方法来响应这个请求的结果： func testObservable() { getObservable(with: githubStr).subscribe(onNext: { (jsonObj) in print(\"Get JSON success\") if jsonObj is Int { print(jsonObj) return } guard JSONSerialization.isValidJSONObject(jsonObj) else { return } if let jsonData = try? JSONSerialization.data(withJSONObject: jsonObj, options: .prettyPrinted) { let jsonStr = String.init(data: jsonData, encoding: String.Encoding.utf8) print(jsonStr ?? \"\") } }, onError: { (error) in if let error = error as? TError { error.printLog() } else { print(error.localizedDescription) } }, onCompleted: { print(\"completed\") }).disposed(by: disposeBag) } Event - 事件 public enum Event { case next(Element) case error(Swift.Error) case completed } next - 序列产生了一个新的元素 error - 创建序列时产生了一个错误，导致序列终止 completed - 序列的所有元素都已经成功产生，整个序列已经完成 你可以合理的利用这些 Event 来实现业务逻辑。 Single https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/single.html public struct PrimitiveSequence { let source: Observable init(raw: Observable) { self.source = raw } } public enum SingleTrait { } public typealias Single = PrimitiveSequence Single 是 Observable 的另外一个版本。不像 Observable 可以发出多个元素，它要么只能发出一个元素，要么产生一个 error 事件。 发出一个元素，或一个 error 事件 不会共享状态变化 一个比较常见的例子就是执行 HTTP 请求，然后返回一个应答或错误。不过你也可以用 Single 来描述任何只有一个元素的序列。 如何创建 Single 创建 Single 和创建 Observable 非常相似： func getRepo(_ repo: String) -> Single { return Single.create { (single) -> Disposable in guard let url = URL.init(string: \"https://api.github.com/repos/\\(repo)\") else { let err = TError.init(errorCode: 10, errorString: \"url error\", errorData: nil) single(.error(err)) return Disposables.create() } let task = URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) in if error != nil { let err = TError.init(errorCode: 20, errorString: \"request error\", errorData: data) single(.error(err)) return } guard let jsonData = data, let jsonObj = try? JSONSerialization.jsonObject(with: jsonData, options: .mutableLeaves), let result = jsonObj as? [String: Any] else { let err = TError.init(errorCode: 30, errorString: \"json error\", errorData: data) single(.error(err)) return } single(.success(result)) // 只会运行第一个single single(.success([\"1\":2])) }) task.resume() return Disposables.create { task.cancel() } } } 之后，你可以这样使用 Single： func testSingle() { getRepo(\"ReactiveX/RxSwift\") .subscribe(onSuccess: { (dict) in print(dict) }, onError: { (error) in guard let err = error as? TError else { print(error.localizedDescription) return } err.printLog() }) .disposed(by: disposeBag) }} 订阅提供一个 SingleEvent 的枚举： public enum SingleEvent { case success(Element) case error(Swift.Error) } success - 产生一个单独的元素 error - 产生一个错误 你同样可以对 Observable 调用 .asSingle() 方法，将它转换为 Single，事件的对应关系如下： Event => SingleEvent 1 * next(Element) + completed => success(Element) n * next(Element) + completed or error(Swift.Error) => error(Swift.Error) eg: func testObservableAsSingle() { getObservable(with: githubStr) .asSingle() .subscribe(onSuccess: { (jsonObj) in // 1*onNext + 1*onCompleted print(\"Get JSON success\") if jsonObj is Int { print(jsonObj) return } guard JSONSerialization.isValidJSONObject(jsonObj) else { return } if let jsonData = try? JSONSerialization.data(withJSONObject: jsonObj, options: .prettyPrinted) { let jsonStr = String.init(data: jsonData, encoding: String.Encoding.utf8) print(jsonStr ?? \"\") } }, onError: { (error) in // n*onNext + 1*onCompleted || onError if let error = error as? TError { error.printLog() } else { print(error.localizedDescription) } }) .disposed(by: disposeBag) } Completable https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/completeable.html public struct PrimitiveSequence { let source: Observable init(raw: Observable) { self.source = raw } } public enum CompletableTrait { } public typealias Completable = PrimitiveSequence Completable 是 Observable 的另外一个版本。不像 Observable 可以发出多个元素，它要么只能产生一个 completed 事件，要么产生一个 error 事件。 发出零个元素 发出一个 completed 事件或者一个 error 事件 不会共享状态变化 Completable 适用于那种你只关心任务是否完成，而不需要在意任务返回值的情况。它和 Observable 有点相似。 如何创建 Completable 创建 Completable 和创建 Observable 非常相似： func getCompletable() -> Completable { return Completable.create { (completable) -> Disposable in guard let url = URL.init(string: \"http://www.baidu.com/\") else { completable(.error(TError.init(errorCode: 10, errorString: \"url error\", errorData: nil))) return Disposables.create() } let task = URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) in if let errInfo = error { completable(.error(errInfo)) } else { completable(.completed) } }) task.resume() return Disposables.create { task.cancel() } } } 之后，你可以这样使用 Completable： func testCompletable() { getCompletable() .subscribe(onCompleted: { print(\"Completable onCompleted\") }, onError: { (error) in if let err = error as? TError { err.printLog() return } print(error.localizedDescription) }) .disposed(by: disposeBag) } Maybe https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/maybe.html public struct PrimitiveSequence { let source: Observable init(raw: Observable) { self.source = raw } } public enum MaybeTrait { } public typealias Maybe = PrimitiveSequence Maybe 是 Observable 的另外一个版本。它介于 Single 和 Completable 之间，它要么只能发出一个元素，要么产生一个 completed 事件，要么产生一个 error 事件。 发出一个元素或者一个 completed 事件或者一个 error 事件 不会共享状态变化 如果你遇到那种可能需要发出一个元素，又可能不需要发出时，就可以使用 Maybe。 如何创建 Maybe 创建 Maybe 和创建 Observable 非常相似： func getMaybe() -> Maybe { return Maybe.create { (maybe) -> Disposable in guard let url = URL.init(string: \"http://www.baidu.com/\") else { maybe(.error(TError.init(errorCode: 10, errorString: \"url error\", errorData: nil))) return Disposables.create() } let task = URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) in if let errInfo = error { maybe(.error(errInfo)) return } if let data = data { maybe(.success(data)) return } // 无错误也无数据返回 maybe(.completed) }) task.resume() return Disposables.create { task.cancel() } } } 之后，你可以这样使用 Maybe： testMaybe() { getMaybe() .subscribe(onSuccess: { (data) in print(data.debugDescription) }, onError: { (err) in if let err = err as? TError { err.printLog() return } print(err.localizedDescription) }, onCompleted: { print(\"Completed With No Data\") }) .disposed(by: disposeBag) } 订阅提供一个 MaybeEvent 的枚举： public enum MaybeEvent { case success(Element) case error(Swift.Error) case completed } 你同样可以对 Observable 调用 .asMaybe() 方法，将它转换为 Maybe。事件的对应关系如下： Event => MaybeEvent 1 * next(Element) + completed => success(Element) n * next(Element) + completed or error(Swift.Error) => error(Swift.Error) 1 * completed => completed func testObservableAsMaybe() { getObservable(with: githubStr) .asMaybe() .subscribe(onSuccess: { (jsonObj) in // 1*onNext + 1*onCompleted print(\"Get JSON success\") if jsonObj is Int { print(jsonObj) return } guard JSONSerialization.isValidJSONObject(jsonObj) else { return } if let jsonData = try? JSONSerialization.data(withJSONObject: jsonObj, options: .prettyPrinted) { let jsonStr = String.init(data: jsonData, encoding: String.Encoding.utf8) print(jsonStr ?? \"\") } }, onError: { (error) in // n*onNext + 1*onCompleted || onError if let error = error as? TError { error.printLog() } else { print(error.localizedDescription) } }, onCompleted: { // 1*onCompleted print(\"completed\") }) .disposed(by: disposeBag) } Driver https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html public protocol ObservableConvertibleType { associatedtype E func asObservable() -> Observable } public protocol SharedSequenceConvertibleType : ObservableConvertibleType { associatedtype SharingStrategy: SharingStrategyProtocol func asSharedSequence() -> SharedSequence } public struct SharedSequence : SharedSequenceConvertibleType { ... ... } public struct DriverSharingStrategy: SharingStrategyProtocol { public static var scheduler: SchedulerType { return SharingScheduler.make() } public static func share(_ source: Observable) -> Observable { return source.share(replay: 1, scope: .whileConnected) } } public typealias Driver = SharedSequence Driver（司机？） 是一个精心准备的特征序列。它主要是为了简化 UI 层的代码。不过如果你遇到的序列具有以下特征，你也可以使用它： 不会产生 error 事件 一定在 MainScheduler 监听（主线程监听） 共享状态变化 这些都是驱动 UI 的序列所具有的特征。 为什么要使用 Driver ？ 我们举个例子来说明一下，为什么要使用 Driver。 这是文档简介页的例子： let results = query.rx.text .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest { query in fetchAutoCompleteItems(query) } results .map { \"\\($0.count)\" } .bind(to: resultCount.rx.text) .disposed(by: disposeBag) results .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) { (_, result, cell) in cell.textLabel?.text = \"\\(result)\" } .disposed(by: disposeBag) 这段代码的主要目的是： 取出用户输入稳定后的内容 向服务器请求一组结果 将返回的结果绑定到两个 UI 元素上：tableView 和 显示结果数量的label 那么这里存在什么问题？ 如果 fetchAutoCompleteItems 的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求。 如果 fetchAutoCompleteItems 在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃。 返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果。 一个更好的方案是这样的： let results = query.rx.text .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest { query in fetchAutoCompleteItems(query) .observeOn(MainScheduler.instance) // 结果在主线程返回 .catchErrorJustReturn([]) // 错误被处理了，这样至少不会终止整个序列 } .share(replay: 1) // HTTP 请求是被共享的 results .map { \"\\($0.count)\" } .bind(to: resultCount.rx.text) .disposed(by: disposeBag) results .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) { (_, result, cell) in cell.textLabel?.text = \"\\(result)\" } .disposed(by: disposeBag) 在一个大型系统内，要确保每一步不被遗漏是一件不太容易的事情。所以更好的选择是合理运用编译器和特征序列来确保这些必备条件都已经满足。 以下是使用 Driver 优化后的代码： let results = query.rx.text.asDriver() // 将普通序列转换为 Driver .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest { query in fetchAutoCompleteItems(query) .asDriver(onErrorJustReturn: []) // 仅仅提供发生错误时的备选返回值 } results .map { \"\\($0.count)\" } .drive(resultCount.rx.text) // 这里改用 `drive` 而不是 `bindTo` .disposed(by: disposeBag) // 这样可以确保必备条件都已经满足了 results .drive(resultsTableView.rx.items(cellIdentifier: \"Cell\")) { (_, result, cell) in cell.textLabel?.text = \"\\(result)\" } .disposed(by: disposeBag) 首先第一个 asDriver 方法将 ControlProperty 转换为 Driver 然后第二个变化是： .asDriver(onErrorJustReturn: []) 任何可被监听的序列都可以被转换为 Driver，只要他满足 3 个条件： 不会产生 error 事件 一定在 MainScheduler 监听（主线程监听） 共享状态变化 那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。asDriver(onErrorJustReturn: []) 相当于以下代码： let safeSequence = xs .observeOn(MainScheduler.instance) // 主线程监听 .catchErrorJustReturn(onErrorJustReturn) // 无法产生错误 .share(replay: 1, scope: .whileConnected)// 共享状态变化 return Driver(raw: safeSequence) // 封装 最后使用 drive 而不是 bindTo drive 方法只能被 Driver 调用。这意味着，如果你发现代码所存在 drive，那么这个序列不会产生错误事件并且一定在主线程监听。这样你可以安全的绑定 UI 元素。 eg: func testObservableAsDriver() { func getImage() -> Observable { return Observable.create { (observer) -> Disposable in let downloadToken = SDWebImageDownloader.shared().downloadImage( with: URL.init(string: \"https://avatars1.githubusercontent.com/u/11990850\"), options: SDWebImageDownloaderOptions.highPriority, progress: nil, completed: { (image, data, error, finished) in if let img = image { observer.onNext(img) observer.onCompleted() return } if let err = error { observer.onError(err) return } observer.onError(TError.init(errorCode: 10, errorString: \"UNKNOW ERROR\", errorData: data)) } ) return Disposables.create { SDWebImageDownloader.shared().cancel(downloadToken) } } } getImage() .asDriver(onErrorJustReturn: #imageLiteral(resourceName: \"placeholderImg\")) .drive(self.imageView.rx.image) .disposed(by: disposeBag) } ControlEvent https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/control_event.html public protocol ObservableType : ObservableConvertibleType { func subscribe(_ observer: O) -> Disposable where O.E == E } public protocol ControlEventType : ObservableType { func asControlEvent() -> ControlEvent } public struct ControlEvent : ControlEventType { ... ... } ControlEvent 专门用于描述 UI 控件所产生的事件，它具有以下特征： 不会产生 error 事件 一定在 MainScheduler 订阅（主线程订阅） 一定在 MainScheduler 监听（主线程监听） 共享状态变化 func testControlEvent() { // extension Reactive where Base: UIButton { // // /// Reactive wrapper for `TouchUpInside` control event. // public var tap: ControlEvent { // return controlEvent(.touchUpInside) // } // } let disposeBag = DisposeBag() self.btn.rx.tap .subscribe(onNext: { [weak self] in let ac = UIAlertController.init(title: \"TEST TAP(touchUpInside)\", message: \"testControlEvent\", preferredStyle: UIAlertControllerStyle.alert) ac.addAction(UIAlertAction.init(title: \"确定\", style: UIAlertActionStyle.cancel, handler: nil)) self?.present(ac, animated: true, completion: nil) }) .disposed(by: disposeBag) self.btn.rx.controlEvent(UIControlEvents.touchDragExit) .subscribe(onNext: { [weak self] in let ac = UIAlertController.init(title: \"TEST touchDragExit\", message: \"testControlEvent\", preferredStyle: UIAlertControllerStyle.alert) ac.addAction(UIAlertAction.init(title: \"确定\", style: UIAlertActionStyle.cancel, handler: nil)) self?.present(ac, animated: true, completion: nil) }) .disposed(by: disposeBag) } 总结 Observable => Event public enum Event { case next(Element) case error(Swift.Error) case completed } Single => SingleEvent 发出一个元素，或一个 error 事件 不会共享状态变化 public enum SingleEvent { case success(Element) case error(Swift.Error) } Event => SingleEvent 1 * next(Element) + completed => success(Element) n * next(Element) + completed or error(Swift.Error) => error(Swift.Error) Completable 要么只能产生一个 completed 事件，要么产生一个 error 事件。适用于那种你只关心任务是否完成，而不需要在意任务返回值的情况。它和 Observable 有点相似。 发出零个元素 发出一个 completed 事件或者一个 error 事件 不会共享状态变化 Maybe => MaybeEvent 发出一个元素或者一个 completed 事件或者一个 error 事件 不会共享状态变化 public enum MaybeEvent { case success(Element) case error(Swift.Error) case completed } Event => MaybeEvent 1 * next(Element) + completed => success(Element) n * next(Element) + completed or error(Swift.Error) => error(Swift.Error) 1 * completed => completed Driver observableValue.asDriver(onErrorJustReturn: ElementType) 将 Observable 转为 Driver 类型 不会产生 error 事件 一定在 MainScheduler 监听（主线程监听） 共享状态变化 ControlEvent control.rx.controlEvent(UIControlEvents.touchUpInside).subscribe(...) ControlEvent 专门用于描述 UI 控件所产生的事件 不会产生 error 事件 一定在 MainScheduler 订阅（主线程订阅） 一定在 MainScheduler 监听（主线程监听） 共享状态变化 "},"RxSwiftStudy/2.Observer-观察者.html":{"url":"RxSwiftStudy/2.Observer-观察者.html","title":"2. Observer - 观察者","keywords":"","body":"Observer - 观察者 https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observer.html 观察者 是用来监听事件，然后它需要这个事件做出响应。例如：弹出提示框就是观察者，它对点击按钮这个事件做出响应。 如何创建观察者 和 Observable 一样，框架已经帮我们创建好了许多常用的观察者。例如：view 是否隐藏，button 是否可点击， label 的当前文本，imageView 的当前图片等等。另外，有一些自定义的观察者是需要我们自己创建的。 tap.subscribe(onNext: { [weak self] in self?.showAlert() }, onError: { error in print(\"发生错误： \\(error.localizedDescription)\") }, onCompleted: { print(\"任务完成\") }) 创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述，事件发生时，需要如何做出响应。而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的。 以上是创建观察者最常见的方法。当然你还可以通过其他的方式来创建观察者，详见 AnyObserver AnyObserver https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observer/any_observer.html public protocol ObserverType { ... ... } public struct AnyObserver : ObserverType { ... ... } AnyObserver 可以用来描叙任意一种观察者。 创建方式： let observer: AnyObserver = AnyObserver.init { (event) in switch event { case .next(let value): // 序列处理 case .error(let error): // error case .completed: // 完成 } } eg： 准备代码： func getObservable(with url: String) -> Observable { return Observable.create { (observer) -> Disposable in guard let url = URL.init(string: url) else { let err = TError.init(errorCode: 10, errorString: \"url error\", errorData: nil) observer.onError(err) return Disposables.create() } let request = URLRequest.init(url: url) let task = URLSession.shared.dataTask(with: request, completionHandler: { (data, response, error) in if let err = error { observer.onError(err) return } guard let jsonData = data, let jsonObj = try? JSONSerialization.jsonObject(with: jsonData, options: .mutableLeaves) else { let err = TError.init(errorCode: 11, errorString: \"json error\", errorData: data) observer.onError(err) return } observer.onNext(jsonObj) observer.onCompleted() }) task.resume() return Disposables.create { task.cancel() } } } 以前的做法： func theGeneralPractice() { getObservable(with: \"https://api.github.com/\") .subscribe(onNext: { (jsonObj) in print(\"Get JSON success\") guard JSONSerialization.isValidJSONObject(jsonObj) else { return } if let jsonData = try? JSONSerialization.data(withJSONObject: jsonObj, options: .prettyPrinted) { let jsonStr = String.init(data: jsonData, encoding: String.Encoding.utf8) print(jsonStr ?? \"\") } }, onError: { (error) in if let error = error as? TError { error.printLog() } else { print(error.localizedDescription) } }, onCompleted: { print(\"completed\") }) .disposed(by: disposeBag) } 相当于： func testCreateObserver() { let observer: AnyObserver = AnyObserver.init { (event) in switch event { case .next(let jsonObj): print(\"Get JSON success\") guard JSONSerialization.isValidJSONObject(jsonObj) else { return } if let jsonData = try? JSONSerialization.data(withJSONObject: jsonObj, options: .prettyPrinted) { let jsonStr = String.init(data: jsonData, encoding: String.Encoding.utf8) print(jsonStr ?? \"\") } case .error(let error): if let err = error as? TError { err.printLog() } else { print(error.localizedDescription) } case .completed: print(\"completed\") } } getObservable(with: \"https://api.github.com/\") .subscribe(observer) .disposed(by: disposeBag) } Binder https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observer/binder.html public protocol ObserverType { ... ... } public struct Binder: ObserverType { ... ... } Binder 主要有以下两个特征： 不会处理错误事件 确保绑定都是在给定 [Scheduler] 上执行（默认 MainScheduler） 一旦产生错误事件，在调试环境下将执行 fatalError，在发布环境下将打印错误信息。 示例 在介绍 AnyObserver 时，我们举了这样一个例子： let observer: AnyObserver = AnyObserver { [weak self] (event) in switch event { case .next(let isHidden): self?.usernameValidOutlet.isHidden = isHidden default: break } } usernameValid .bind(to: observer) .disposed(by: disposeBag) 由于这个观察者是一个 UI 观察者，所以它在响应事件时，只会处理 next 事件，并且更新 UI 的操作需要在主线程上执行。 因此一个更好的方案就是使用 Binder： let observer: Binder = Binder(usernameValidOutlet) { (view, isHidden) in view.isHidden = isHidden } usernameValid .bind(to: observer) .disposed(by: disposeBag) Binder 可以只处理 next 事件，并且保证响应 next 事件的代码一定会在给定 [Scheduler] 上执行，这里采用默认的 MainScheduler。 复用 由于页面是否隐藏是一个常用的观察者，所以应该让所有的 UIView 都提供这种观察者： extension Reactive where Base: UIView { public var isHidden: Binder { return Binder(self.base) { view, hidden in view.isHidden = hidden } } } usernameValid .bind(to: usernameValidOutlet.rx.isHidden) .disposed(by: disposeBag) 这样你不必为每个 UI 控件单独创建该观察者。这就是 usernameValidOutlet.rx.isHidden 的由来，许多 UI 观察者 都是这样创建的： 按钮是否可点击 button.rx.isEnabled： extension Reactive where Base: UIControl { public var isEnabled: Binder { return Binder(self.base) { control, value in control.isEnabled = value } } } label 的当前文本 label.rx.text： extension Reactive where Base: UILabel { public var text: Binder { return Binder(self.base) { label, text in label.text = text } } } 你也可以用这种方式来创建自定义的 UI 观察者。 eg: 准备代码： func getImage() -> Observable { return Observable.create { (observer) -> Disposable in let downloadToken = SDWebImageDownloader.shared().downloadImage( with: URL.init(string: \"https://avatars1.githubusercontent.com/u/11990850\"), options: SDWebImageDownloaderOptions.highPriority, progress: nil, completed: { (image, data, error, finished) in if let img = image { observer.onNext(img) observer.onCompleted() return } if let err = error { observer.onError(err) return } observer.onError(TError.init(errorCode: 10, errorString: \"UNKNOW ERROR\", errorData: data)) } ) return Disposables.create { SDWebImageDownloader.shared().cancel(downloadToken) } } } 之前的调用方式： getImage().asDriver(onErrorJustReturn: #imageLiteral(resourceName: \"placeholderImg\")) .drive(imageView.rx.image) .disposed(by: disposeBag) 其中 imageView.rx.image 定义中有 Binder 的定义： extension Reactive where Base: UIImageView { /// Bindable sink for `image` property. public var image: Binder { return Binder(base) { imageView, image in imageView.image = image } } } 相当于： func testCreateImageViewBinderObserver() { let observer: Binder = Binder.init(imageView) { (imageView, image) in imageView.image = image } getImage() .asDriver(onErrorJustReturn: #imageLiteral(resourceName: \"placeholderImg\")) .drive(observer) .disposed(by: disposeBag) // getImage() // .observeOn(MainScheduler.instance) // .bind(to: observer) // .disposed(by: disposeBag) } 总结 AnyObserver let observer: AnyObserver = AnyObserver.init { (event) in switch event { case .next(let value): // 序列处理 case .error(let error): // error case .completed: // 完成 } } someObservableVar.subscribe(observer).disposed(by: disposeBag) Binder let observer: Binder = Binder.init(imageView) { (imageView, image) in imageView.image = image } let placeholderImage = #imageLiteral(resourceName: \"placeholderImg\") someImageObservableVar.asDriver(onErrorJustReturn: placeholderImage).drive(observer).disposed(by: disposeBag) // 或 // someImageObservableVar.observeOn(MainScheduler.instance).bind(to: observer).disposed(by: disposeBag) "},"RxSwiftStudy/3.Observable&Observer-既是可被监听的序列也是观察者.html":{"url":"RxSwiftStudy/3.Observable&Observer-既是可被监听的序列也是观察者.html","title":"3. Observable & Observer 既是可被监听的序列也是观察者","keywords":"","body":"Observable & Observer - 既是可被监听的序列也是观察者 https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer.html 在我们所遇到的事物中，有一部分非常特别。它们既是可被监听的序列也是观察者。 例如：textField的当前文本。它可以看成是由用户输入，而产生的一个文本序列。也可以是由外部文本序列，来控制当前显示内容的观察者： // 作为可被监听的序列 let observable = textField.rx.text observable.subscribe(onNext: { text in show(text: text) }) // 作为观察者 let observer = textField.rx.text let text: Observable = ... text.bind(to: observer) 看下 textField的 rx.text 的定义 public var text: ControlProperty { return value } /// Reactive wrapper for `text` property. public var value: ControlProperty { return base.rx.controlPropertyWithDefaultEvents( getter: { textField in textField.text }, setter: { textField, value in // This check is important because setting text value always clears control state // including marked text selection which is imporant for proper input // when IME input method is used. if textField.text != value { textField.text = value } } ) } 看下 ControlProperty 是啥 public protocol ControlPropertyType : ObservableType, ObserverType { ... } public struct ControlProperty : ControlPropertyType { ... ... } 有许多 UI 控件都存在这种特性，例如：switch的开关状态，segmentedControl的选中索引号，datePicker的选中日期等等。 另外，框架里面定义了一些辅助类型，它们既是可被监听的序列也是观察者。如果你能合适的应用这些辅助类型，它们就可以帮助你更准确的描述事物的特征。 AsyncSubject https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/async_subject.html public final class AsyncSubject : Observable , SubjectType , ObserverType , SynchronizedUnsubscribeType { ... ... } 如果源 Observable在发出多个元素并产生完成事件后， AsyncSubject 发出最后一个元素（仅仅只有最后一个元素）； 如果源 Observable 没有发出任何元素，只有一个完成事件， AsyncSubject 也只有一个完成事件。 如果源 Observable 因为产生了一个 error 事件而中止， AsyncSubject 就不会发出任何元素，而是将这个 error 事件发送出来。 创建方法： let subject = AsyncSubject() eg： func testAsyncSubject() { let subject = AsyncSubject() subject .subscribe({ (e) in print(\"Subscription: 1 Event:\", e) }) .disposed(by: disposeBag) // 1 subject.onNext(\"🐶\") subject.onNext(\"🐱\") // 只发送 onCompleted前面最后一个 subject.onNext(\"🐹\") subject.onCompleted() } 输出如下： Subscription: 1 Event: next(🐹) Subscription: 1 Event: completed PublishSubject https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/publish_subject.html public final class PublishSubject : Observable , SubjectType , Cancelable , ObserverType , SynchronizedUnsubscribeType { ... ... } 对观察者发送订阅后产生的元素 在观察者订阅前发出的元素不会重新发送给观察者（只会发送订阅之后产生的元素给这个订阅者） 如果你希望观察者接收到所有的元素，你可以通过使用 Observable 的 create 方法来创建 Observable，或者使用 ReplaySubject。 创建方法： let subject = PublishSubject() eg： func testPublishSubject() { let disposeBag = DisposeBag() let subject = PublishSubject() subject .subscribe({ (e) in print(\"Subscription: 1 Event:\", e) }) .disposed(by: disposeBag) subject.onNext(\"🐶\") subject.onNext(\"🐱\") subject .subscribe({ (e) in print(\"Subscription: 2 Event:\", e) }) .disposed(by: disposeBag) subject.onNext(\"🅰️\") subject.onNext(\"🅱️\") subject.onCompleted() } 输出如下： Subscription: 1 Event: next(🐶) Subscription: 1 Event: next(🐱) Subscription: 1 Event: next(🅰️) Subscription: 2 Event: next(🅰️) Subscription: 1 Event: next(🅱️) Subscription: 2 Event: next(🅱️) Subscription: 1 Event: completed Subscription: 2 Event: completed ReplaySubject https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/replay_subject.html public class ReplaySubject : Observable , SubjectType , ObserverType , Disposable { ... ... } 对观察者发送全部的元素，无论观察者是何时进行订阅的。会按顺序补发订阅之前产生的元素 这里存在多个版本的 ReplaySubject，有的只会将最新的 n 个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。 如果把 ReplaySubject 当作观察者来使用，注意不要在多个线程调用 onNext, onError 或 onCompleted。这样会导致无序调用，将造成意想不到的结果。 创建方法： // 缓存所有已产生的元素 let subject = ReplaySubject.createUnbounded() // 缓存指定数量的已产生的元素 let subject = ReplaySubject.create(bufferSize: 1) eg： func testReplaySubject() { // let subject = ReplaySubject.createUnbounded() let subject = ReplaySubject.create(bufferSize: 1) subject .subscribe { print(\"Subscription: 1 Event:\", $0) } .disposed(by: disposeBag) subject.onNext(\"🐶\") subject.onNext(\"🐱\") subject .subscribe { print(\"Subscription: 2 Event:\", $0) } .disposed(by: disposeBag) subject.onNext(\"🅰️\") subject.onNext(\"🅱️\") } 输出如下： Subscription: 1 Event: next(🐶) Subscription: 1 Event: next(🐱) Subscription: 2 Event: next(🐱) Subscription: 1 Event: next(🅰️) Subscription: 2 Event: next(🅰️) Subscription: 1 Event: next(🅱️) Subscription: 2 Event: next(🅱️) BehaviorSubject https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/behavior_subject.html public final class BehaviorSubject : Observable , SubjectType , ObserverType , SynchronizedUnsubscribeType , Disposable { ... ... } 当观察者对 BehaviorSubject 进行订阅时，它会将源 Observable 中最新的元素发送出来 如果不存在最新的元素，就发出默认元素。 每当产生新的元素，都会发送给观察者。 如果源 Observable 因为产生了一个 error 事件而中止， BehaviorSubject 就不会发出任何元素，而是将这个 error 事件发送出来。 eg： func testBehaviorSubject() { let subject = BehaviorSubject(value: \"🔴\") subject .subscribe { print(\"Subscription: 1 Event:\", $0) } .disposed(by: disposeBag) subject.onNext(\"🐶\") subject.onNext(\"🐱\") subject .subscribe { print(\"Subscription: 2 Event:\", $0) } .disposed(by: disposeBag) subject.onNext(\"🅰️\") subject.onNext(\"🅱️\") subject .subscribe { print(\"Subscription: 3 Event:\", $0) } .disposed(by: disposeBag) subject.onNext(\"🍐\") subject.onNext(\"🍊\") } 输出如下： Subscription: 1 Event: next(🔴) Subscription: 1 Event: next(🐶) Subscription: 1 Event: next(🐱) Subscription: 2 Event: next(🐱) Subscription: 1 Event: next(🅰️) Subscription: 2 Event: next(🅰️) Subscription: 1 Event: next(🅱️) Subscription: 2 Event: next(🅱️) Subscription: 3 Event: next(🅱️) Subscription: 1 Event: next(🍐) Subscription: 2 Event: next(🍐) Subscription: 3 Event: next(🍐) Subscription: 1 Event: next(🍊) Subscription: 2 Event: next(🍊) Subscription: 3 Event: next(🍊) Variable https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/variable.html public final class Variable { ... ... } 在 Swift 中我们经常会用 var 关键字来声明变量。RxSwift 提供的 Variable 实际上是 var 的 Rx 版本，你可以将它看作是 RxVar。 我们来对比一下 var 以及 Variable 的用法： 使用 var： // 在 ViewController 中 var model: Model? = nil { didSet { updateUI(with: model) } } override func viewDidLoad() { super.viewDidLoad() model = getModel() } func updateUI(with model: Model?) { ... } func getModel() -> Model { ... } 使用 Variable： // 在 ViewController 中 let model: Variable = Variable(nil) override func viewDidLoad() { super.viewDidLoad() model.asObservable() .subscribe(onNext: { [weak self] model in self?.updateUI(with: model) }) .disposed(by: disposeBag) model.value = getModel() } func updateUI(with model: Model?) { ... } func getModel() -> Model { ... } 第一种使用 var 的方式十分常见，在 ViewController 中监听 Model 的变化，然后刷新页面。 第二种使用 Variable 则是 RxSwift 独有的。Variable 几乎提供了 var 的所有功能。另外，加上一条非常重要的特性，就是可以通过调用 asObservable() 方法转换成序列。然后你可以对这个序列应用操作符，来合成其他的序列。所以，如果我们声明的变量需要提供 Rx 支持，那就选用 Variable 这个类型。 说明: Variable 封装了一个 BehaviorSubject，所以它会持有当前值，并且 Variable 会对新的观察者发送当前值。它不会产生 error 事件。Variable 在 deinit 时，会发出一个 completed 事件。 eg: func testVariable() { struct Model { var text: String? var image: UIImage? } func updateView(with model: Model?) { guard let m = model else { return } DispatchQueue.main.async { self.imageView.image = m.image print(m.text ?? \"none\") } } let model: Variable = Variable.init(nil) model .asObservable() .subscribe(onNext: { (m) in updateView(with: m) }) .disposed(by: disposeBag) getImage() .subscribe(onNext: { (image) in model.value = Model.init(text: image.description, image: image) }, onError: { (err) in if let err = err as? TError { err.printLog() return } print(err.localizedDescription) }) .disposed(by: disposeBag) } ControlProperty https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable_and_observer/control_property.html public protocol ControlPropertyType : ObservableType, ObserverType { /// - returns: `ControlProperty` interface func asControlProperty() -> ControlProperty } public struct ControlProperty : ControlPropertyType { ... ... } ControlProperty 专门用于描述 UI 控件属性的，它具有以下特征： 不会产生 error 事件 一定在 MainScheduler 订阅（主线程订阅） 一定在 MainScheduler 监听（主线程监听） 共享状态变化 eg: func testControlProperty() { // 仅仅用于测试，主要用于UI控件，例如 textField.rx.text // Creat: var c_value: String = \"\" let c_observable = Observable.create({ (observer) -> Disposable in observer.onNext(c_value) observer.onCompleted() return Disposables.create() }) let c_observer = AnyObserver.init { (e) in switch e { case .next(let el): c_value = el default: break } print(\"controlProperty is Changed: \" + e.debugDescription) } let controlProperty = ControlProperty.init(values: c_observable, valueSink: c_observer) // USE: let observable = Observable.create({ (observer) -> Disposable in observer.onNext(\"测试1\") observer.onNext(\"测试2\") observer.onCompleted() return Disposables.create() }) let observer = AnyObserver.init { (e) in print(\"controlProperty Value Is: \" + e.debugDescription) } observable .bind(to: controlProperty) .disposed(by: disposeBag) controlProperty .bind(to: observer) .disposed(by: disposeBag) } 附录 Subject相关的一些 Protocol | Class | Struct 定义 ObservableType public protocol ObservableConvertibleType { /// Type of elements in sequence. associatedtype E /// Converts `self` to `Observable` sequence. /// /// - returns: Observable sequence that represents `self`. func asObservable() -> Observable } public protocol ObservableType : ObservableConvertibleType { /** Subscribes `observer` to receive events for this sequence. ### Grammar **Next\\* (Error | Completed)?** * sequences can produce zero or more elements so zero or more `Next` events can be sent to `observer` * once an `Error` or `Completed` event is sent, the sequence terminates and can't produce any other elements It is possible that events are sent from different threads, but no two events can be sent concurrently to `observer`. ### Resource Management When sequence sends `Complete` or `Error` event all internal resources that compute sequence elements will be freed. To cancel production of sequence elements and free resources immediately, call `dispose` on returned subscription. - returns: Subscription for `observer` that can be used to cancel production of sequence elements and free resources. */ func subscribe(_ observer: O) -> Disposable where O.E == E } Observable public class Observable : ObservableType { ... ... } SubjectType public protocol SubjectType : ObservableType { /// The type of the observer that represents this subject. /// /// Usually this type is type of subject itself, but it doesn't have to be. associatedtype SubjectObserverType : ObserverType /// Returns observer interface for subject. /// /// - returns: Observer interface for subject. func asObserver() -> SubjectObserverType } ObserverType public protocol ObserverType { /// The type of elements in sequence that observer can observe. associatedtype E /// Notify observer about sequence event. /// /// - parameter event: Event that occurred. func on(_ event: Event) } SynchronizedUnsubscribeType protocol SynchronizedUnsubscribeType : class { associatedtype DisposeKey func synchronizedUnsubscribe(_ disposeKey: DisposeKey) } Disposable public protocol Disposable { /// Dispose resource. func dispose() } "},"RxSwiftStudy/4.Disposable-可被清除的资源.html":{"url":"RxSwiftStudy/4.Disposable-可被清除的资源.html","title":"4. Disposable - 可被清除的资源","keywords":"","body":"Observable dispose 的时机 https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/disposable.html Observable 发出了 completed 或者 error 事件之后会直接释放 如果一直没 completed 或者 error, 调用 dispose() 会提前 dispose 如果一直没 completed 或者 error, 若调用 disposed(by: disposeBag), disposeBag 释放时候 Observable 才会 dispose 测试代码： class DisposableViewController: UIViewController { let disposeBag = DisposeBag() deinit { print(\"Deinit:\" + self.debugDescription) } override func viewDidLoad() { super.viewDidLoad() testDisposeTime() } // MARK: DisposeTime func testDisposeTime() { // observer.onCompleted()之后会直接dispose // 如果一直没 onCompleted(), 调用dispose()才会dispose // 如果一直没 onCompleted(), 调用disposed(by: disposeBag), disposeBag释放时候才会dispose // Observable 1: 不发送 .onCompleted() 不调用 .dispose() _ = Observable .create({ (observer) -> Disposable in observer.onNext( \"\"\" \\n Observable 1: 不发送 .onCompleted() 不调用 .dispose() \\t\\t\\t 永远不会释放 \"\"\" ) return Disposables.create { print(\"Observable 1: Now Dispose\") } }) .subscribe(onNext: { (s) in print(s) }) // Observable 2: 会发送 .onCompleted() 的 Observable _ = Observable .create({ (observer) -> Disposable in observer.onNext( \"\"\" \\n Observable 2: 会发送 .onCompleted() 的 Observable \\t\\t\\t 完成后就会释放 \"\"\" ) observer.onCompleted() return Disposables.create { print(\"Observable 2: Now Dispose\") } }) .subscribe(onNext: { (s) in print(s) }) // Observable 3: 不发送 .onCompleted() , 调用 .dispose() Observable .create({ (observer) -> Disposable in observer.onNext( \"\"\" \\n Observable 3: 不发送 .onCompleted() , 调用 .dispose() \\t\\t\\t 调用 .dispose() 时候释放 \"\"\" ) return Disposables.create { print(\"Observable 3: Now Dispose\") } }) .subscribe(onNext: { (s) in print(s) }) .dispose() // Observable 4: 不发送 .onCompleted() , 调用 .disposed(by: disposeBag) Observable .create({ (observer) -> Disposable in observer.onNext( \"\"\" \\n Observable 4: 不发送 .onCompleted() , 调用 .disposed(by: disposeBag) \\t\\t\\t disposeBag释放时候(VC deinit之后)释放 \"\"\" ) return Disposables.create { print(\"Observable 4: Now Dispose\") } }) .subscribe(onNext: { (s) in print(s) }) .disposed(by: disposeBag) } } 输出如下： Observable 1: 不发送 .onCompleted() 不调用 .dispose() 永远不会释放 Observable 2: 会发送 .onCompleted() 的 Observable 完成后就会释放 Observable 2: Now Dispose Observable 3: 不发送 .onCompleted() , 调用 .dispose() 调用 .dispose() 时候释放 Observable 3: Now Dispose Observable 4: 不发送 .onCompleted() , 调用 .disposed(by: disposeBag) disposeBag释放时候(VC deinit之后)释放 Deinit: Observable 4: Now Dispose Disposable - 可被清除的资源 https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/disposable.html 通常来说，一个序列如果发出了 error 或者 completed 事件，那么所有内部资源都会被释放。如果你需要提前释放这些资源或取消订阅的话，那么你可以对返回的 可被清除的资源（Disposable） 调用 dispose 方法。 调用 dispose 方法后，订阅将被取消，并且内部资源都会被释放。通常情况下，你是不需要手动调用 dispose 方法的，这里只是做个演示而已。我们推荐使用 清除包（DisposeBag） 或者 takeUntil 操作符 来管理订阅的生命周期。 func testDispose() { for i in 1...4 { Observable .create({ (observer) -> Disposable in observer.onNext(\"Observable \\(i) onNext\") return Disposables.create { print(\"Observable \\(i): Now Dispose\") } }) .subscribe({ (e) in print(e) }) .dispose() } } 输出如下 next(Observable 1 onNext) Observable 1: Now Dispose next(Observable 2 onNext) Observable 2: Now Dispose next(Observable 3 onNext) Observable 3: Now Dispose next(Observable 4 onNext) Observable 4: Now Dispose DisposeBag - 清除包 因为我们用的是 Swift ，所以我们更习惯于使用 ARC 来管理内存。那么我们能不能用 ARC 来管理订阅的生命周期了。答案是肯定了，你可以用 清除包（DisposeBag） 来实现这种订阅管理机制。当 清除包(DisposeBag) 被释放的时候，清除包 内部所有 可被清除的资源（Disposable） 都将被清除。 func testDisposeBag() { let funcDisposeBag = DisposeBag() for i in 1...4 { Observable .create({ (observer) -> Disposable in observer.onNext(\"Observable \\(i) onNext\") return Disposables.create { print(\"Observable \\(i) Now Dispose\") } }) .subscribe({ (e) in print(e) }) .disposed(by: funcDisposeBag) } } 输出如下： next(Observable 1 onNext) next(Observable 2 onNext) next(Observable 3 onNext) next(Observable 4 onNext) Observable 1 Now Dispose Observable 2 Now Dispose Observable 3 Now Dispose Observable 4 Now Dispose 这个例子中 funcDisposeBag 在函数运行完之后释放，当函数运行结束时， funcDisposeBag 就被释放，那么这里的 4 次订阅也就被取消了。 takeUntil 另外一种实现自动取消订阅的方法就是使用 takeUntil 操作符，上面的演示代码也可以通过使用 takeUntil 来实现： @IBAction func testTakeUntil() { for i in 1...4 { let observable = Observable.create({ (observer) -> Disposable in observer.onNext(\"Observable \\(i) onNext\") return Disposables.create { print(\"Observable \\(i): Now Dispose\") } }) _ = observable .takeUntil(self.rx.deallocated) .subscribe({ (e) in print(\"Observable \\(i): \" + e.debugDescription) }) } } 这将使得订阅一直持续到控制器的 dealloc 事件产生为止。输出为： Observable 1: next(Observable 1 onNext) Observable 2: next(Observable 2 onNext) Observable 3: next(Observable 3 onNext) Observable 4: next(Observable 4 onNext) Deinit: Observable 1: completed Observable 1: Now Dispose Observable 2: completed Observable 2: Now Dispose Observable 3: completed Observable 3: Now Dispose Observable 4: completed Observable 4: Now Dispose "},"RxSwiftStudy/5.Schedulers-调度器.html":{"url":"RxSwiftStudy/5.Schedulers-调度器.html","title":"5. Schedulers - 调度器","keywords":"","body":"Schedulers - 调度器 https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html Schedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。 如果你曾经使用过 GCD， 那你对以下代码应该不会陌生： // 后台取得数据，主线程处理结果 DispatchQueue.global(qos: .userInitiated).async { let data = try? Data(contentsOf: url) DispatchQueue.main.async { self.data = data } } 如果用 RxSwift 来实现，大致是这样的： let rxData: Observable = ... rxData .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated)) .observeOn(MainScheduler.instance) .subscribe(onNext: { [weak self] data in self?.data = data }) .disposed(by: disposeBag) 使用 subscribeOn 我们用 subscribeOn 来决定数据序列的构建函数在哪个 Scheduler 上运行。以上例子中，由于获取 Data 需要花很长的时间，所以用 subscribeOn 切换到 后台 Scheduler 来获取 Data。这样可以避免主线程被阻塞。 eg: 首先写一些辅助代码： // getCurrentQueueName() -> String func getCurrentQueueName() -> String { let name = __dispatch_queue_get_label(nil) return String.init(cString: name, encoding: .utf8) ?? \"\" } // MARK: getObservable() -> Observable func getObservable() -> Observable { return Observable.create { [weak self] (observer) -> Disposable in guard let strongSelf = self else { return Disposables.create() } print(\"Observable Queue Is: \" + strongSelf.getCurrentQueueName()) // 当前线程直接发送元素 observer.on(.next(\"Test 1\")) DispatchQueue.main.async { // 切换到主线程发送元素 observer.on(.next(\"Test 2\")) } return Disposables.create() } } // MARK: getObserver() -> AnyObserver func getObserver() -> AnyObserver { return AnyObserver.init(eventHandler: { [weak self] (e) in guard let strongSelf = self else { return } print(\"AnyObserver Queue Is: \" + strongSelf.getCurrentQueueName()) print(\"\\t\\t\" + e.debugDescription) }) } 测试代码如下： func testSubscribeOn() { let subscribeQueue = DispatchQueue.init(label: \"ink.tbd.test.subscribeQueue\") getObservable() // 数据序列的构建函数在哪个Scheduler上运行 .subscribeOn(ConcurrentDispatchQueueScheduler.init(queue: subscribeQueue)) .subscribe(getObserver()) .disposed(by: disposeBag) } 输出如下： Observable Queue Is: ink.tbd.test.subscribeQueue AnyObserver Queue Is: ink.tbd.test.subscribeQueue next(Test 1) AnyObserver Queue Is: com.apple.main-thread next(Test 2) 可以知道： subscribeOn(_ scheduler: ImmediateSchedulerType) 可以使 Observable 的主体在指定线程中运行 Observer响应事件的线程受到 Observable 代码中中发送事件所在的线程影响，在什么线程中发送，响应也就在什么线程之中 使用 observeOn 我们用 observeOn 来决定在哪个 Scheduler 监听这个数据序列。以上例子中，通过使用 observeOn 方法切换到主线程来监听并且处理结果。 一个比较典型的例子就是，在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 subscribeOn 切到后台去发送请求并解析数据，最后用 observeOn 切换到主线程更新页面。 eg: func testObserveOn() { let observeQueue = DispatchQueue.init(label: \"ink.tbd.test.observeQueue\") getObservable() // 在哪个Scheduler监听这个数据序列 .observeOn(ConcurrentDispatchQueueScheduler.init(queue: observeQueue)) .subscribe(getObserver()) .disposed(by: disposeBag) } 运行结果如下： Observable Queue Is: com.apple.main-thread AnyObserver Queue Is: ink.tbd.test.observeQueue next(Test 1) AnyObserver Queue Is: ink.tbd.test.observeQueue next(Test 2) 可以知道： observeOn(_ scheduler: ImmediateSchedulerType) 可以使 Observer 的主体在指定线程中运行，不管 Observable 代码中发送事件在什么线程，都会切换到指定线程执行。 RxSwift中提供的Scheduler MainScheduler MainScheduler 代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler 运行。 SerialDispatchQueueScheduler SerialDispatchQueueScheduler 抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。 ConcurrentDispatchQueueScheduler ConcurrentDispatchQueueScheduler 抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。 OperationQueueScheduler OperationQueueScheduler 抽象了 NSOperationQueue。 它具备 NSOperationQueue 的一些特点，例如，你可以通过设置 maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。 "},"RxSwiftStudy/6.ErrorHandling-错误处理.html":{"url":"RxSwiftStudy/6.ErrorHandling-错误处理.html","title":"6. Error Handling - 错误处理","keywords":"","body":"Error Handling - 错误处理 https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/error_handling.html 一旦序列里面产出了一个 error 事件，整个序列将被终止。RxSwift 主要有两种错误处理机制： retry - 重试 catch - 恢复 retry retry 可以让序列在发生错误后重试： // 请求失败时，立即重试， // 重试 3 次后仍然失败，就将错误抛出 func testRetry() { getDictObservable() .retry(3) // 总共调用3次包括第一次 .subscribe({ (e) in print(\"in the end: \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 以上的代码非常直接 retry(3) 就是当发生错误时，就进行重试操作，并且最多重试 3 次。 retryWhen 如果我们需要在发生错误时，经过一段延时后重试，那可以这样实现： func testRetryWhen() { let retryDelay: RxTimeInterval = 1.0 getDictObservable() .retryWhen({ (rxError) -> Observable in return rxError.flatMap({ (e) -> Observable in return Observable.timer(retryDelay, scheduler: MainScheduler.instance) }) }) .subscribe({ (e) in print(\"in the end: \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 这里我们需要用到 retryWhen 操作符，这个操作符主要描述应该在何时重试，并且通过闭包里面返回的 Observable 来控制重试的时机： .retryWhen { (rxError: Observable) -> Observable in ... } 闭包里面的参数是 Observable 也就是所产生错误的序列，然后返回值是一个 Observable。当这个返回的 Observable 发出一个元素时，就进行重试操作。当它发出一个 error 或者 completed 事件时，就不会重试，并且将这个事件传递给到后面的观察者。 如果需要加上一个最大重试次数的限制： func testRetryWhenAndMaxRetry() { let retryDelay: RxTimeInterval = 1.0 let maxRetryCount: Int = 4 getDictObservable() .retryWhen({ (rxError) -> Observable in return rxError.enumerated().flatMap({ (index, element) -> Observable in // 最多 4 次 if index >= maxRetryCount { let err = TError.init(errorCode: 0, errorString: \"Retry Too Many Times\", errorData: nil) return Observable.error(err) } return Observable.timer(retryDelay, scheduler: MainScheduler.instance) }) }) .subscribe({ (e) in print(\"in the end: \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 我们这里要实现的是，如果重试超过 4 次，就将错误抛出。如果错误在 4 次以内时，就等待 1 秒后重试： ... rxError.flatMapWithIndex { (error, index) -> Observable in guard index .timer(retryDelay, scheduler: MainScheduler.instance) } ... 我们用 flatMapWithIndex 这个操作符，因为它可以给我们提供错误的索引数 index。然后用这个索引数判断是否超过最大重试数，如果超过了，就将错误抛出。如果没有超过，就等待 5 秒后重试。 catchErrorJustReturn - 恢复 catchErrorJustReturn 可以在错误产生时，用一个备用元素或者一组备用元素将错误替换掉： func testCatchErrorJustReturn() { let defaultDict = [\"returnDefaultDict\": \"Is DefaultDict\"] getDictObservable() .catchErrorJustReturn(defaultDict) .subscribe ({ (e) in print(e) }) .disposed(by: disposeBag) } catchErrorJustReturn 当错误产生时，就返回一个空数组，于是就会显示一个空列表页。 你也可以使用 catchError，当错误产生时，将错误事件替换成一个备选序列： func testCatchError() { let defaultDictVariable: Variable = Variable.init([\"returnDefaultDict\": \"Is DefaultDictVariable\"]) getDictObservable() .catchError({ (error) -> Observable in return defaultDictVariable.asObservable() }) .subscribe ({ (e) in print(e) }) .disposed(by: disposeBag) } Result 如果我们只是想给用户错误提示，那要如何操作呢？ 以下提供一个最为直接的方案，不过这个方案存在一些问题： // 当用户点击更新按钮时， // 就立即取出修改后的用户信息。 // 然后发起网络请求，进行更新操作， // 一旦操作失败就提示用户失败原因 updateUserInfoButton.rx.tap .withLatestFrom(rxUserInfo) .flatMapLatest { userInfo -> Observable in return update(userInfo) } .observeOn(MainScheduler.instance) .subscribe(onNext: { print(\"用户信息更新成功\") }, onError: { error in print(\"用户信息更新失败： \\(error.localizedDescription)\") }) .disposed(by: disposeBag) 这样实现是非常直接的。但是一旦网络请求操作失败了，序列就会终止。整个订阅将被取消。如果用户再次点击更新按钮，就无法再次发起网络请求进行更新操作了。 为了解决这个问题，我们需要选择合适的方案来进行错误处理。例如使用枚举 Result： // 自定义一个枚举类型 Result public enum Result { case success(T) case failure(Swift.Error) } 然后之前的代码需要修改成： updateUserInfoButton.rx.tap .withLatestFrom(rxUserInfo) .flatMapLatest { userInfo -> Observable> in return update(userInfo) .map(Result.success) // 转换成 Result .catchError { error in Observable.just(Result.failure(error)) } } .observeOn(MainScheduler.instance) .subscribe(onNext: { result in switch result { // 处理 Result case .success: print(\"用户信息更新成功\") case .failure(let error): print(\"用户信息更新失败： \\(error.localizedDescription)\") } }) .disposed(by: disposeBag) 这样我们的错误事件被包装成了 Result.failure(Error) 元素，就不会终止整个序列。就算网络请求失败，整个订阅依然存在。如果用户再次点击更新按钮，也是能够发起网络请求进行更新操作的。 示例： // MARK: ═══════════════════════════════════════ // MARK: Test ResultModel // MARK: ═══════════════════════════════════════ @IBOutlet weak var testInPreviousWayButton: UIButton! @IBOutlet weak var testResultModelButton: UIButton! override func viewDidLoad() { super.viewDidLoad() testInPreviousWay() testResultModel() } // testInPreviousWay func testInPreviousWay() { // 如果这部分代码只会运行一次（只进行一次绑定） // 此时如果发生error事件之后则被丢弃，后续点击则无法再响应 testInPreviousWayButton.rx.tap .flatMapLatest({ [unowned self] (_) -> Observable in return self.getDictObservable() }) .subscribe(onNext: { [unowned self] (dict) in print(\"Button is Taped: \\(self.testInPreviousWayButton.titleLabel?.text ?? \"\" ) \") print(\"get dict success: \\(dict)\") }, onError: { (_) in // 此处一旦进入，订阅将失效，后续点击不会响应 print(\"Button is Taped: \\(self.testInPreviousWayButton.titleLabel?.text ?? \"\" ) \") // err.printLog() }) .disposed(by: disposeBag) } // testResultModel func testResultModel() { enum ResultModel { case success(T) case failure(Error) } // 如果这部分代码只会运行一次（只进行一次绑定） // 此时如果发生error事件之后则会被转成ResultMode.failure(err) // 此时拦截了error事件，订阅不会丢弃，后续点击可以继续响应 testResultModelButton.rx.tap .flatMapLatest({ [unowned self] (_) -> Observable> in return self.getDictObservable() .map(ResultModel.success) .catchError({ (error) -> Observable> in return Observable.just(ResultModel.failure(error)) }) }) .subscribe(onNext: { [unowned self] (resultModel) in switch resultModel { case .success(let dict): print(\"Is In ResultModel & Button is Taped: \\(self.testResultModelButton.titleLabel?.text ?? \"\" ) \") print(\"get dict success: \\(dict)\") case .failure(_): print(\"Is In ResultModel & Button is Taped: \\(self.testResultModelButton.titleLabel?.text ?? \"\" ) \") // err.printLog() } }, onError: { [unowned self] (err) in // 此处永远不会进入 print(\"Is In Subscribe Error & Button is Taped: \\(self.testResultModelButton.titleLabel?.text ?? \"\" ) \") err.printLog() }) .disposed(by: disposeBag) } 另外你也可以使用 materialize 操作符来进行错误处理。这里就不详细介绍了，如你想了解如何使用 materialize 可以参考这篇文章 How to handle errors in RxSwift "},"RxSwiftStudy/7.Operator-操作符.html":{"url":"RxSwiftStudy/7.Operator-操作符.html","title":"7. Operator - 操作符","keywords":"","body":"Operator - 操作符 官方文档 http://reactivex.io/documentation/operators.html 中文翻译文档 https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html 准备测试使用的方法 Debug debug do 创建 Observable create never empty just error from of range repeatElement defer interval timer 变换 Observable toArray map scan flatMap flatMapFirst flatMapLatest flatMapWithIndex concatMap buffer window groupBy 过滤 Observable ignoreElements elementAt filter debounce throttle distinctUntilChanged sample skip skipWhile skipUntil take takeLast takeWhile takeUntil single 联合 Observable startWith combineLatest zip withLatestFrom merge switchLatest 错误处理操作符 catchError catchErrorJustReturn retry retryWhen 条件和 Bool 操作符 amb skipWhile skipUntil takeWhile takeUntil 数学和聚合操作符 concat reduce 连接 Observable 操作符 multicast publish connect refCount replay share shareReplay shareReplayLatestWhileConnected About Time delay delaySubscription defer interval timer timeout Scheduler observeOn subscribeOn Materialize materialize dematerialize Using using "},"RxSwiftStudy/Operator/Prepare.html":{"url":"RxSwiftStudy/Operator/Prepare.html","title":"7.00 准备测试使用的方法","keywords":"","body":"准备测试使用的方法 一些经常在测试中使用到的Observable getFirstObservable() -> Observable 1s observer.onNext(\"First -> 1|A\") observer.onNext(\"First -> 1|B\") observer.onNext(\"First -> 1|C\") 5s observer.onNext(\"First -> 2|A\") observer.onNext(\"First -> 2|B\") observer.onNext(\"First -> 2|C\") 9s observer.onNext(\"First -> 3|A\") observer.onNext(\"First -> 3|B\") observer.onNext(\"First -> 3|C\") observer.onCompleted() func getFirstObservable() -> Observable { return Observable.create({ (observer) -> Disposable in // section 1 delayTime(1, block: { observer.onNext(\"First -> 1|A\") observer.onNext(\"First -> 1|B\") observer.onNext(\"First -> 1|C\") }) // section 2 delayTime(5, block: { observer.onNext(\"First -> 2|A\") observer.onNext(\"First -> 2|B\") observer.onNext(\"First -> 2|C\") }) // section 3 delayTime(9, block: { observer.onNext(\"First -> 3|A\") observer.onNext(\"First -> 3|B\") observer.onNext(\"First -> 3|C\") observer.onCompleted() }) return Disposables.create() }) } getSecondObservable() -> Observable 0.1s observer.onNext(\"Second -> 1\") 4.1s observer.onNext(\"Second -> 2\") 8.1s observer.onNext(\"Second -> 3\") observer.onCompleted() func getSecondObservable() -> Observable { return Observable.create({ (observer) -> Disposable in delayTime(0.1, block: { observer.onNext(\"Second -> 1\") delayTime(4, block: { observer.onNext(\"Second -> 2\") }) delayTime(8, block: { observer.onNext(\"Second -> 3\") observer.onCompleted() }) }) return Disposables.create() }) } getThirdObservable() -> Observable 0.1s observer.onNext(\"Third -> 1\") observer.onNext(\"Third -> 2\") observer.onNext(\"Third -> 3\") observer.onCompleted() func getThirdObservable() -> Observable { return Observable.create({ (observer) -> Disposable in delayTime(0.1, block: { observer.onNext(\"Third -> 1\") observer.onNext(\"Third -> 2\") observer.onNext(\"Third -> 3\") observer.onCompleted() }) return Disposables.create() }) } getFourthObservable() -> Observable 0s print(\"> Send onNext(\\\"0️⃣\\\")\") observer.onNext(\"0️⃣\") 1s print(\"> Send onNext(\\\"1️⃣\\\")\") observer.onNext(\"1️⃣\") 2s print(\"> Send onNext(\\\"2️⃣\\\")\") observer.onNext(\"2️⃣\") func getFourthObservable() -> Observable { let observable = Observable.create({ (observer) -> Disposable in print(\"> Send onNext(\\\"0️⃣\\\")\") observer.onNext(\"0️⃣\") delayTime(1, block: { print(\"> Send onNext(\\\"1️⃣\\\")\") observer.onNext(\"1️⃣\") }) delayTime(2, block: { print(\"> Send onNext(\\\"2️⃣\\\")\") observer.onNext(\"2️⃣\") }) return Disposables.create() }) return observable } getErrorObservable() -> Observable 1s observer.onNext(\"1️⃣\") 2s observer.onNext(\"2️⃣\") 3s let err = TError.init(errorCode: 10, errorString: \"Test\", errorData: nil) observer.onError(err) func getErrorObservable() -> Observable { return Observable.create({ (observer) -> Disposable in delayTime(1, block: { observer.onNext(\"1️⃣\") }) delayTime(2, block: { observer.onNext(\"2️⃣\") }) delayTime(3, block: { let err = TError.init(errorCode: 10, errorString: \"Test\", errorData: nil) observer.onError(err) }) return Disposables.create() }) } "},"RxSwiftStudy/Operator/Debug.html":{"url":"RxSwiftStudy/Operator/Debug.html","title":"7.01 Debug Operator","keywords":"","body":"Debug Operator debug 打印所有的订阅，事件以及销毁信息 eg: func debug() { getFirstObservable() // identifier: 描述， trimOutput: 是否截取最多四十个字符 .debug(\"Test Debug\", trimOutput: true) .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 09:14:12.680: Test Debug -> subscribed 2017-12-27 09:14:13.683: Test Debug -> Event next(First -> 1|A) 2017-12-27 09:14:13.683: Test Debug -> Event next(First -> 1|B) 2017-12-27 09:14:13.683: Test Debug -> Event next(First -> 1|C) 2017-12-27 09:14:17.683: Test Debug -> Event next(First -> 2|A) 2017-12-27 09:14:17.683: Test Debug -> Event next(First -> 2|B) 2017-12-27 09:14:17.683: Test Debug -> Event next(First -> 2|C) 2017-12-27 09:14:21.683: Test Debug -> Event next(First -> 3|A) 2017-12-27 09:14:21.683: Test Debug -> Event next(First -> 3|B) 2017-12-27 09:14:21.683: Test Debug -> Event next(First -> 3|C) 2017-12-27 09:14:21.683: Test Debug -> Event completed 2017-12-27 09:14:21.683: Test Debug -> isDisposed do 当 Observable 产生某些事件时，执行某个操作 当 Observable 的某些事件产生时，你可以使用 do 操作符来注册一些回调操作。 这些回调会被单独调用，它们会和 Observable 原本的回调分离。 eg: func `do`() { let observable = Observable.create({ (observer) -> Disposable in delayTime(1, block: { observer.onNext(\"1️⃣\") }) delayTime(2, block: { observer.onNext(\"2️⃣\") }) delayTime(3, block: { observer.onNext(\"3️⃣\") observer.onCompleted() }) return Disposables.create() }) observable .do(onNext: { (str) in print(\"do --> \" + str) }, onError: { (error) in print(\"do --> \") error.printLog() }, onCompleted: { print(\"do --> onCompleted\") }, onSubscribe: { print(\"do --> onSubscribe\") }, onSubscribed: { print(\"do --> onSubscribed\") }, onDispose: { print(\"do --> onDispose\") }) .subscribe({ (e) in print(\"in subscribe --> \\(e)\") }) .disposed(by: disposeBag) } 输出如下： do --> onSubscribe do --> onSubscribed do --> 1️⃣ in subscribe --> next(1️⃣) do --> 2️⃣ in subscribe --> next(2️⃣) do --> 3️⃣ in subscribe --> next(3️⃣) do --> onCompleted in subscribe --> completed do --> onDispose "},"RxSwiftStudy/Operator/Create.html":{"url":"RxSwiftStudy/Operator/Create.html","title":"7.02 创建 Observable","keywords":"","body":"创建 Observable - Create Observable Operator create create 操作符将创建一个 Observable，你需要提供一个构建函数，在构建函数里面描述事件（next，error，completed）的产生过程。 通常情况下一个有限的序列，只会调用一次观察者的 onCompleted 或者 onError 方法。并且在调用它们后，不会再去调用观察者的其他方法。 eg: func create() { _ = Observable.create { (observer) -> Disposable in observer.onNext(\"1\") observer.onNext(\"2\") observer.onNext(\"3\") observer.onNext(\"4\") observer.onNext(\"5\") observer.onNext(\"6\") observer.onNext(\"7\") observer.onCompleted() return Disposables.create() } } never 创建一个永远不会发出元素的 Observable never 操作符将创建一个 Observable，这个 Observable 不会产生任何事件。 eg: func never() { let observable = Observable.never() observable .subscribe({ (e) in print(e) }) .disposed(by: disposeBag) } empty 创建一个空 Observable empty 操作符将创建一个 Observable，这个 Observable 只有一个完成事件。 eg: func empty() { let observable = Observable.empty() // 相当于以下代码 // let observable = Observable.create { observer in // observer.onCompleted() // return Disposables.create() // } observable .debug(\"Empty\") .subscribe() .disposed(by: disposeBag) } 输出： 2017-12-27 09:25:19.926: Empty -> subscribed 2017-12-27 09:25:19.926: Empty -> Event completed 2017-12-27 09:25:19.926: Empty -> isDisposed just 创建 Observable 发出唯一的一个元素 just 操作符将某一个元素转换为 Observable。 eg: func just() { let justObservable = Observable.just(\"A String\") // 相当于： // let justObservable = Observable.create { observer in // observer.onNext(\"A String\") // observer.onCompleted() // return Disposables.create() // } justObservable .subscribe({ (e) in print(\"just => \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下： just => next(A String) just => completed error 创建一个只有 error 事件的 Observable error 操作符将创建一个 Observable，这个 Observable 只会产生一个 error 事件。 eg: func error() { let err = TError.init(errorCode: 10, errorString: \"test error\", errorData: nil) let observable = Observable.error(err) // 相当于以下代码 // let err = TError.init(errorCode: 10, errorString: \"test error\", errorData: nil) // let id = Observable.create { observer in // observer.onError(err) // return Disposables.create() // } observable .subscribe({ (e) in print(\"Error --> \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下： Error --> error(TError(errorCode: 10, errorString: \"test error\", errorData: nil)) from 将其他类型或者数据结构转换为 Observable, 当你在使用 Observable 时，如果能够直接将其他类型转换为 Observable，这将是非常省事的。 from 操作符就提供了这种功能，将一个数组转换为 Observable eg: func from() { let array = [34, 2, 44, 21, 54] let observable = Observable.from(array) // 相当于 // let observable = Observable.create { (observer) -> Disposable in // observer.onNext(34) // observer.onNext(2) // observer.onNext(44) // observer.onNext(21) // observer.onNext(54) // observer.onCompleted() // return Disposables.create() // } observable .subscribe({ (e) in print(\"From Array => \\(e.debugDescription)\") }) .disposed(by: disposeBag) // 将一个可选值转换为 Observable： let optionalInt: Int? = 12 let observableOptional = Observable.from(optional: optionalInt) // 相当于 // let optionalInt: Int? = 12 // let observableOptional = Observable.create { observer in // if let value = optionalInt { // observer.onNext(value) // } // observer.onCompleted() // return Disposables.create() // } observableOptional .subscribe({ (e) in print(\"From Optional => \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下： From Array => next(34) From Array => next(2) From Array => next(44) From Array => next(21) From Array => next(54) From Array => completed From Optional => next(12) From Optional => completed of of 操作符将某一个元素或多个元素转换为 Observable。 eg: func of() { let ofObservable = Observable.of(1, 2, 3) // let ofObservable = Observable.of(1, 2, 3, scheduler: MainScheduler.instance) // 相当于: // let ofObservable = Observable.create { observer in // observer.onNext(1) // observer.onNext(2) // observer.onNext(3) // observer.onCompleted() // return Disposables.create() // } ofObservable .subscribe({ (e) in print(\"Of => \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下 Of => next(1) Of => next(2) Of => next(3) Of => completed range 创建一个发射特定范围的顺序整数的 Observable eg: func range() { let rangeObservable = Observable.range(start: 10, count: 30, scheduler: MainScheduler.instance) rangeObservable .debug(\"range\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 09:37:15.266: range -> subscribed 2017-12-27 09:37:15.266: range -> Event next(10) 2017-12-27 09:37:15.267: range -> Event next(11) 2017-12-27 09:37:15.267: range -> Event next(12) 2017-12-27 09:37:15.268: range -> Event next(13) 2017-12-27 09:37:15.268: range -> Event next(14) 2017-12-27 09:37:15.268: range -> Event next(15) 2017-12-27 09:37:15.268: range -> Event next(16) 2017-12-27 09:37:15.268: range -> Event next(17) 2017-12-27 09:37:15.268: range -> Event next(18) 2017-12-27 09:37:15.268: range -> Event next(19) 2017-12-27 09:37:15.268: range -> Event next(20) 2017-12-27 09:37:15.268: range -> Event next(21) 2017-12-27 09:37:15.268: range -> Event next(22) 2017-12-27 09:37:15.268: range -> Event next(23) 2017-12-27 09:37:15.268: range -> Event next(24) 2017-12-27 09:37:15.268: range -> Event next(25) 2017-12-27 09:37:15.268: range -> Event next(26) 2017-12-27 09:37:15.268: range -> Event next(27) 2017-12-27 09:37:15.268: range -> Event next(28) 2017-12-27 09:37:15.268: range -> Event next(29) 2017-12-27 09:37:15.268: range -> Event next(30) 2017-12-27 09:37:15.269: range -> Event next(31) 2017-12-27 09:37:15.269: range -> Event next(32) 2017-12-27 09:37:15.269: range -> Event next(33) 2017-12-27 09:37:15.269: range -> Event next(34) 2017-12-27 09:37:15.269: range -> Event next(35) 2017-12-27 09:37:15.269: range -> Event next(36) 2017-12-27 09:37:15.269: range -> Event next(37) 2017-12-27 09:37:15.269: range -> Event next(38) 2017-12-27 09:37:15.269: range -> Event next(39) 2017-12-27 09:37:15.269: range -> Event completed 2017-12-27 09:37:15.269: range -> isDisposed repeatElement repeatElement 操作符将创建一个 Observable，这个 Observable 将无止尽的发出同一个元素。 eg: func repeatElement() { let observable = Observable.repeatElement(10, scheduler: MainScheduler.instance) // 相当于： // let observable = Observable.create { observer in // DispatchQueue.global().async { // while true { // DispatchQueue.main.async { // observer.onNext(0) // } // // 防止阻塞主线程 // Thread.sleep(forTimeInterval: 0.001) // } // } // return Disposables.create() // } observable .debug(\"repeatElement\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 09:39:01.061: repeatElement -> subscribed 2017-12-27 09:39:01.061: repeatElement -> Event next(10) 2017-12-27 09:39:01.062: repeatElement -> Event next(10) 2017-12-27 09:39:01.062: repeatElement -> Event next(10) 2017-12-27 09:39:01.062: repeatElement -> Event next(10) 2017-12-27 09:39:01.062: repeatElement -> Event next(10) 2017-12-27 09:39:01.062: repeatElement -> Event next(10) 2017-12-27 09:39:01.062: repeatElement -> Event next(10) 2017-12-27 09:39:01.063: repeatElement -> Event next(10) 2017-12-27 09:39:01.063: repeatElement -> Event next(10) 2017-12-27 09:39:01.063: repeatElement -> Event next(10) 2017-12-27 09:39:01.063: repeatElement -> Event next(10) ............ ............ defer 直到订阅发生，才创建 Observable，并且为每位订阅者创建全新的 Observable ⚠️注意：是延迟创建 Observable ，而不是延迟订阅或者延迟元素的发出时间 defer 操作符将等待观察者订阅它，才创建一个 Observable，它会通过一个构建函数为每一位订阅者创建新的 Observable。 ⚠️注意：看上去每位订阅者都是对同一个 Observable 产生订阅，实际上它们都获得了独立的序列。其实并不是像以前一样订阅同一个 Observable，实际为每个订阅者都创建了一个 Observable ，在一些情况下，直到订阅时才创建 Observable 是可以保证拿到的数据都是最新的。 eg: func `defer`() { let observable = Observable.deferred { [unowned self] () -> Observable in print(\"Observable is Create Now\") return self.getSecondObservable() } delayTime(2) { print(\"First Subscribe Now\") observable .debug(\"Test Defer: First Subscribe\") .subscribe() .disposed(by: self.disposeBag) } // 测试是否为每位订阅者都创建了 Observable delayTime(5) { print(\"Second Subscribe Now\") observable .debug(\"Test Defer: Second Subscribe\") .subscribe() .disposed(by: self.disposeBag) } } 输出如下： First Subscribe Now 2017-12-27 09:44:31.176: Test Defer: First Subscribe -> subscribed Observable is Create Now 2017-12-27 09:44:31.280: Test Defer: First Subscribe -> Event next(Second -> 1) Second Subscribe Now 2017-12-27 09:44:34.171: Test Defer: Second Subscribe -> subscribed Observable is Create Now 2017-12-27 09:44:34.279: Test Defer: Second Subscribe -> Event next(Second -> 1) 2017-12-27 09:44:35.280: Test Defer: First Subscribe -> Event next(Second -> 2) 2017-12-27 09:44:38.279: Test Defer: Second Subscribe -> Event next(Second -> 2) 2017-12-27 09:44:39.280: Test Defer: First Subscribe -> Event next(Second -> 3) 2017-12-27 09:44:39.280: Test Defer: First Subscribe -> Event completed 2017-12-27 09:44:39.280: Test Defer: First Subscribe -> isDisposed 2017-12-27 09:44:42.279: Test Defer: Second Subscribe -> Event next(Second -> 3) 2017-12-27 09:44:42.279: Test Defer: Second Subscribe -> Event completed 2017-12-27 09:44:42.280: Test Defer: Second Subscribe -> isDisposed interval 创建一个 Observable 每隔一段时间，发出一个索引数 interval 操作符将创建一个 Observable，它每隔一段设定的时间，发出一个索引数的元素。它将发出无数个元素。 eg: func interval() { let intervalQueue = DispatchQueue.init(label: \"ink.tbd.test.interval\") Observable .interval(1, scheduler: ConcurrentDispatchQueueScheduler.init(queue: intervalQueue)) .subscribe({ (e) in print(\"interval => \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下： interval => next(0) interval => next(1) interval => next(2) interval => next(3) interval => next(4) interval => next(5) interval => next(6) interval => next(7) ........... ........... timer 创建一个 Observable 在一段延时后，产生唯一的一个元素 timer 操作符将创建一个 Observable，它在经过设定的一段时间后，产生唯一的一个元素。 ⚠️注意：timer(_:period:scheduler:) 与 interval(_:scheduler:) 的区别 timer(_:period:scheduler:) 的实现： public static func timer(_ dueTime: RxTimeInterval, period: RxTimeInterval? = nil, scheduler: SchedulerType) -> Observable { return Timer( dueTime: dueTime, period: period, scheduler: scheduler ) } interval(_:scheduler:) 的实现： public static func interval(_ period: RxTimeInterval, scheduler: SchedulerType) -> Observable { return Timer(dueTime: period, period: period, scheduler: scheduler ) } eg: func timer() { // dueTime: 初始延时, period: 时间间隔, scheduler: 队列 let timerObservable = Observable.timer(5.0, period: 1, scheduler: MainScheduler.instance) timerObservable .debug(\"timer\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 09:57:16.075: timer -> subscribed 2017-12-27 09:57:21.077: timer -> Event next(0) 2017-12-27 09:57:22.076: timer -> Event next(1) 2017-12-27 09:57:23.077: timer -> Event next(2) 2017-12-27 09:57:24.077: timer -> Event next(3) 2017-12-27 09:57:25.077: timer -> Event next(4) 2017-12-27 09:57:26.077: timer -> Event next(5) 2017-12-27 09:57:27.077: timer -> Event next(6) 2017-12-27 09:57:28.076: timer -> Event next(7) 2017-12-27 09:57:29.076: timer -> Event next(8) 2017-12-27 09:57:30.076: timer -> Event next(9) 2017-12-27 09:57:31.075: timer -> Event next(10) ............ ............ "},"RxSwiftStudy/Operator/Transforming.html":{"url":"RxSwiftStudy/Operator/Transforming.html","title":"7.03 变换 Observable","keywords":"","body":"变换 Observable - Transforming Operator toArray 将 Observable 中的单个元素转换成 Array 的数据结构的 Observable 进行发送 eg: func toArray() { let observable = Observable.of(1, 2, 3, 4, 5, 6) observable .toArray() .debug(\"toArray\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 10:05:30.889: toArray -> subscribed 2017-12-27 10:05:30.893: toArray -> Event next([1, 2, 3, 4, 5, 6]) 2017-12-27 10:05:30.893: toArray -> Event completed 2017-12-27 10:05:30.893: toArray -> isDisposed map 通过一个转换函数，将 Observable 的每个元素转换一遍，map 操作符将源 Observable 的每个元素应用你提供的转换方法，然后返回含有转换结果的 Observable。 func map() { let disposeBag = DisposeBag() Observable.of(1, 2, 3) .map({ (value) -> String in return \"Value is \\(value * 10)\" }) .subscribe({ e in print(\"map => \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下： map => next(Value is 10) map => next(Value is 20) map => next(Value is 30) map => completed scan 持续的将 Observable 的每一个元素应用一个函数，然后发出每一次函数返回的结果。 scan 操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。(这种操作符在其他地方有时候被称作是 accumulator。) 与 reduce 类似，reduce 发送最终结果，scan 发送每个步骤 eg: func scan() { let observable = Observable.of(1, 2, 4, 8, 16, 32, 64, 128, 256, 512) observable .scan(0, accumulator: { (l, r) -> Int in return l + r }) .debug(\"Scan\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 10:09:36.991: Scan -> subscribed 2017-12-27 10:09:36.991: Scan -> Event next(1) 2017-12-27 10:09:36.991: Scan -> Event next(3) 2017-12-27 10:09:36.991: Scan -> Event next(7) 2017-12-27 10:09:36.991: Scan -> Event next(15) 2017-12-27 10:09:36.991: Scan -> Event next(31) 2017-12-27 10:09:36.991: Scan -> Event next(63) 2017-12-27 10:09:36.991: Scan -> Event next(127) 2017-12-27 10:09:36.991: Scan -> Event next(255) 2017-12-27 10:09:36.991: Scan -> Event next(511) 2017-12-27 10:09:36.991: Scan -> Event next(1023) 2017-12-27 10:09:36.991: Scan -> Event completed 2017-12-27 10:09:36.991: Scan -> isDisposed flatMap 将 Observable 的元素转换成其他的 Observable，然后将这些 Observables 合并，flatMap 操作符将源 Observable 的每一个元素应用一个转换方法，将他们转换成 Observables。然后将这些 Observables 的元素合并之后再发送出来。 这个操作符是非常有用的，例如，当 Observable 的元素本生拥有其他的 Observable 时，你可以将所有子 Observables 的元素发送出来。 func flatMap() { let first = BehaviorSubject(value: \"First => 👦🏻\") let second = BehaviorSubject(value: \"Second => 😊\") let variable = Variable(first) variable .asObservable() .flatMap { $0 } .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) first.onNext(\"First => 🐱\") variable.value = second second.onNext(\"Second => 😢\") first.onNext(\"First => 🐶\") first.onNext(\"First => 🐱\") second.onNext(\"Second => 😂\") } 输出如下： First => 👦🏻 First => 🐱 Second => 😊 Second => 😢 First => 🐶 First => 🐱 Second => 😂 flatMapFirst 将 Observable 的元素转换成其他的 Observable，然后取这些 Observables 中的第一个。 只发第一个 Observables 的元素，其他的 Observables 的元素将被忽略掉。 eg: func flatMapFirst() { let first = BehaviorSubject(value: \"First => 👦🏻\") let second = BehaviorSubject(value: \"Second => 😊\") let variable = Variable(first) variable .asObservable() .flatMapFirst{ $0 } .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) first.onNext(\"First => 🐱\") variable.value = second second.onNext(\"Second => 😢\") first.onNext(\"First => 🐶\") first.onNext(\"First => 🐱\") second.onNext(\"Second => 😂\") } 输出如下： First => 👦🏻 First => 🐱 First => 🐶 First => 🐱 flatMapLatest 将 Observable 的元素转换成其他的 Observable，然后取这些 Observables 中最新的一个。 一旦转换出一个新的 Observable，就只发出它的元素，旧的 Observables 的元素将被忽略掉。 eg: func flatMapLatest() { let first = BehaviorSubject(value: \"First => 👦🏻\") let second = BehaviorSubject(value: \"Second => 😊\") let variable = Variable(first) variable .asObservable() .flatMapLatest { $0 } .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) first.onNext(\"First => 🐱\") variable.value = second second.onNext(\"Second => 😢\") first.onNext(\"First => 🐶\") first.onNext(\"First => 🐱\") second.onNext(\"Second => 😂\") } 输出如下： First => 👦🏻 First => 🐱 Second => 😊 Second => 😢 Second => 😂 flatMapWithIndex @available(*, deprecated, message: \"Please use enumerated().flatMap()\") flatMapWithIndex（ .enumerated().flatMap(_:) ） 操作符将 Observable 的元素转换成其他的 Observable，然后取这些 Observables 中指定的一个或者几个。 只发出指定允许的 index 的 Observable 中产生的元素，其他的 Observables 的元素将被忽略掉。 eg: func flatMapWithIndex() { // @available(*, deprecated, message: \"Please use enumerated().flatMap()\") let first = BehaviorSubject(value: \"First => 👦🏻\") let second = BehaviorSubject(value: \"Second => 😊\") let variable = Variable(first) variable .asObservable() .enumerated() .flatMap({ (tuple) -> Observable in let (index, subject) = tuple if index == 1 { return subject } return BehaviorSubject.empty() }) // .enumerated().flatMap(_:) 以前是 // .flatMapWithIndex({ (subject, index) -> Observable in // if index == 1 { // return subject // } // return BehaviorSubject.empty() // }) .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) first.onNext(\"First => 🐱\") variable.value = second second.onNext(\"Second => 😢\") first.onNext(\"First => 🐶\") first.onNext(\"First => 🐱\") second.onNext(\"Second => 😂\") } 输出如下： Second => 😊 Second => 😢 Second => 😂 concatMap concatMap 操作符将源 Observable 的每一个元素应用一个转换方法，将元素转换成 Observable。 eg: func concatMap() { getFirstObservable() .concatMap({ (str) -> Observable in return Observable.of(\"\\(str) + 1️⃣\", \"\\(str) + 2️⃣\", \"\\(str) + 3️⃣\", \"======================\") }) .subscribe({ (e) in print(e) }) .disposed(by: disposeBag) } 输出如下： next(First -> 1|A + 1️⃣) next(First -> 1|A + 2️⃣) next(First -> 1|A + 3️⃣) next(======================) next(First -> 1|B + 1️⃣) next(First -> 1|B + 2️⃣) next(First -> 1|B + 3️⃣) next(======================) next(First -> 1|C + 1️⃣) next(First -> 1|C + 2️⃣) next(First -> 1|C + 3️⃣) next(======================) next(First -> 2|A + 1️⃣) next(First -> 2|A + 2️⃣) next(First -> 2|A + 3️⃣) next(======================) next(First -> 2|B + 1️⃣) next(First -> 2|B + 2️⃣) next(First -> 2|B + 3️⃣) next(======================) next(First -> 2|C + 1️⃣) next(First -> 2|C + 2️⃣) next(First -> 2|C + 3️⃣) next(======================) next(First -> 3|A + 1️⃣) next(First -> 3|A + 2️⃣) next(First -> 3|A + 3️⃣) next(======================) next(First -> 3|B + 1️⃣) next(First -> 3|B + 2️⃣) next(First -> 3|B + 3️⃣) next(======================) next(First -> 3|C + 1️⃣) next(First -> 3|C + 2️⃣) next(First -> 3|C + 3️⃣) next(======================) completed buffer buffer 操作符将缓存 Observable 中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。 eg: func buffer() { getFirstObservable() .buffer(timeSpan: 1, count: 2, scheduler: MainScheduler.instance) .subscribe(onNext: { (strArr) in print(strArr) }) .disposed(by: disposeBag) } 输出如下： [] [\"First -> 1|A\", \"First -> 1|B\"] [\"First -> 1|C\"] [] [] [\"First -> 2|A\", \"First -> 2|B\"] [\"First -> 2|C\"] [] [] [\"First -> 3|A\", \"First -> 3|B\"] [\"First -> 3|C\"] window 将 Observable 分解为多个子 Observable，周期性的将子 Observable 发出来 window 操作符和 buffer 十分相似: \\ 发送出的内容形态 发送的时机 buffer 周期性的将缓存的元素集合发送出来 要等到元素搜集完毕后，才会发出元素序列 window 周期性的将元素集合以 Observable 的形态发送出来 可以实时发出元素序列 eg: func window() { getFirstObservable() .window(timeSpan: 2, count: 3, scheduler: MainScheduler.instance) .subscribe(onNext: { [unowned self] (observable) in print(\"window => onNext(\\(observable))\") observable .subscribe({ (e) in print(\"window|onNext => \\(e)\") }) .disposed(by: self.disposeBag) }, onError: { (err) in print(\"window => onError begin\") err.printLog() print(\"window => onError end\") }, onCompleted: { print(\"window => onCompleted\") }) .disposed(by: disposeBag) } 输出如下： window => onNext(RxSwift.AddRef) window|onNext => next(First -> 1|A) window|onNext => next(First -> 1|B) window|onNext => next(First -> 1|C) window|onNext => completed window => onNext(RxSwift.AddRef) window|onNext => completed window => onNext(RxSwift.AddRef) window|onNext => next(First -> 2|A) window|onNext => next(First -> 2|B) window|onNext => next(First -> 2|C) window|onNext => completed window => onNext(RxSwift.AddRef) window|onNext => completed window => onNext(RxSwift.AddRef) window|onNext => next(First -> 3|A) window|onNext => next(First -> 3|B) window|onNext => next(First -> 3|C) window|onNext => completed window => onNext(RxSwift.AddRef) window|onNext => completed window => onCompleted groupBy 将源 Observable 分解为多个子 Observable，并且每个子 Observable 将源 Observable 中相似的元素发送出来。 groupBy 操作符将源 Observable 分解为多个子 Observable，然后将这些子 Observable 发送出来。 // 它会将元素通过某个键进行分组，然后将分组后的元素序列以 Observable 的形态发送出来。 eg: func groupBy() { enum ObservableValueType { case integer case string case other } let observable = Observable.of(1, 2, 3, 4, \"22\", \"23\", \"34\", \"54\", \"12\", 44, \"112\", 65) observable .groupBy(keySelector: { (value) -> ObservableValueType in if value is Int { return ObservableValueType.integer } if value is String { return ObservableValueType.string } return ObservableValueType.other }) .subscribe(onNext: { [unowned self] (group) in group .subscribe({ (e) in print(\"\\(group.key)\\t=> \\(e.debugDescription)\") }) .disposed(by: self.disposeBag) }) .disposed(by: disposeBag) } 输出如下： integer => next(1) integer => next(2) integer => next(3) integer => next(4) string => next(22) string => next(23) string => next(34) string => next(54) string => next(12) integer => next(44) string => next(112) integer => next(65) integer => completed string => completed "},"RxSwiftStudy/Operator/Filtering.html":{"url":"RxSwiftStudy/Operator/Filtering.html","title":"7.04 过滤 Observable","keywords":"","body":"过滤 Observable - Filtering Operator ignoreElements 忽略掉所有的元素，只发出 error 或 completed 事件 ignoreElements 操作符将阻止 Observable 发出 next 事件，但是允许他发出 error 或 completed 事件。 如果你并不关心 Observable 的任何元素，你只想知道 Observable 在什么时候终止，那就可以使用 ignoreElements 操作符。 eg: func ignoreElements() { Observable.of(1, 2, 3, 4, 5) .ignoreElements() .debug(\"ignoreElements\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 11:12:47.786: ignoreElements -> subscribed 2017-12-27 11:12:47.787: ignoreElements -> Event completed 2017-12-27 11:12:47.787: ignoreElements -> isDisposed elementAt elementAt 操作符将拉取 Observable 序列中指定索引数的元素，然后将它作为唯一的元素发出。 eg: func elementAt() { Observable.of(1, 2, 3, 4, 5) .elementAt(1) .subscribe({ (e) in print(\"elementAt subscribe -> \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下： elementAt subscribe -> next(2) elementAt subscribe -> completed filter filter 操作符将通过你提供的判定方法过滤一个 Observable。仅仅发出 Observable 中通过判定的元素。 eg: func filter() { Observable .of(21, 3, 15, 50, 4, 23, 90, 11) .debug(\"Filter : \") .filter({ (value) -> Bool in return value >= 20 }) .debug(\"Subscribe : \") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 11:16:48.888: Subscribe : -> subscribed 2017-12-27 11:16:48.888: Filter : -> subscribed 2017-12-27 11:16:48.888: Filter : -> Event next(21) 2017-12-27 11:16:48.888: Subscribe : -> Event next(21) 2017-12-27 11:16:48.888: Filter : -> Event next(3) 2017-12-27 11:16:48.888: Filter : -> Event next(15) 2017-12-27 11:16:48.888: Filter : -> Event next(50) 2017-12-27 11:16:48.888: Subscribe : -> Event next(50) 2017-12-27 11:16:48.888: Filter : -> Event next(4) 2017-12-27 11:16:48.888: Filter : -> Event next(23) 2017-12-27 11:16:48.888: Subscribe : -> Event next(23) 2017-12-27 11:16:48.888: Filter : -> Event next(90) 2017-12-27 11:16:48.888: Subscribe : -> Event next(90) 2017-12-27 11:16:48.888: Filter : -> Event next(11) 2017-12-27 11:16:48.888: Filter : -> Event completed 2017-12-27 11:16:48.888: Subscribe : -> Event completed 2017-12-27 11:16:48.889: Subscribe : -> isDisposed 2017-12-27 11:16:48.889: Filter : -> isDisposed debounce 用于过滤一定时间内发出的高频元素，只发送最后一个。debounce 操作符将发出这种元素，在 Observable 产生这种元素后，一段时间内没有新元素产生。 eg: func debounce() { getFirstObservable() .debounce(1, scheduler: MainScheduler.instance) .subscribe({ (e) in print(e) }) .disposed(by: disposeBag) } 输出如下： next(First -> 1|C) next(First -> 2|C) next(First -> 3|C) completed throttle 返回在指定连续时间窗口期间中，由源 Observable 发出的第一个和最后一个元素。这个运算符确保没有两个元素在少于 dueTime 的时间发送。 eg: func throttle() { let subject = BehaviorSubject.init(value: 0) subject .asObserver() // 2秒内第一个和最后一个发出的元素 .throttle(2, latest: true, scheduler: MainScheduler.instance) .subscribe({ (e) in print(e) }) .disposed(by: disposeBag) subject.onNext(1) subject.onNext(2) subject.onNext(3) delayTime(3) { // 不会发送onNext(4)，因为onNext(3)在上一个2秒的窗口中，最后延迟到2秒发送出来， // onNext(4)是在第3秒进行发送，此时 onNext(4)的发送时间减去onNext(3)发送时间小于2，所以被忽略 // 因为throttle会确保没有两个元素在少于dueTime的时间 subject.onNext(4) subject.onNext(5) subject.onNext(6) } delayTime(8.2) { subject.onNext(7) } delayTime(12.2) { subject.onNext(8) subject.onNext(9) subject.onNext(10) subject.onCompleted() } } 输出如下： next(0) next(3) next(6) next(7) next(8) next(10) completed distinctUntilChanged distinctUntilChanged 操作符将阻止 Observable 发出相同的元素。如果后一个元素和前一个元素是相同的，那么这个元素将不会被发出来。如果后一个元素和前一个元素不相同，那么这个元素才会被发出来。 eg: func distinctUntilChanged() { let observable = Observable.of(\"🐱\", \"🐷\", \"🐱\", \"🐱\", \"🐱\", \"🐵\", \"🐵\", \"🐵\", \"🐵\", \"🐱\") observable .distinctUntilChanged() .debug(\"distinctUntilChanged\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 11:23:01.265: distinctUntilChanged -> subscribed 2017-12-27 11:23:01.269: distinctUntilChanged -> Event next(🐱) 2017-12-27 11:23:01.270: distinctUntilChanged -> Event next(🐷) 2017-12-27 11:23:01.270: distinctUntilChanged -> Event next(🐱) 2017-12-27 11:23:01.270: distinctUntilChanged -> Event next(🐵) 2017-12-27 11:23:01.270: distinctUntilChanged -> Event next(🐱) 2017-12-27 11:23:01.270: distinctUntilChanged -> Event completed 2017-12-27 11:23:01.270: distinctUntilChanged -> isDisposed sample sample 操作符将不定期的对源 Observable 进行取样操作。 通过第二个 Observable 来控制取样时机。一旦第二个 Observable 发出一个元素，就从源(第一个) Observable 中取出最后产生的元素（如果这段时间内没发出元素，则不取）。 eg: func sample() { let sampleObservable = Observable.interval(1, scheduler: MainScheduler.instance) let observable = getFirstObservable() .sample(sampleObservable) observable .debug(\"sample\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 11:24:47.642: sample -> subscribed 2017-12-27 11:24:48.643: sample -> Event next(First -> 1|C) 2017-12-27 11:24:52.644: sample -> Event next(First -> 2|C) 2017-12-27 11:24:56.643: sample -> Event next(First -> 3|C) 2017-12-27 11:24:56.643: sample -> Event completed 2017-12-27 11:24:56.643: sample -> isDisposed skip skip 操作符可以让你跳过 Observable 中头 n 个元素，只关注后面的元素。 eg: func skip() { Observable .of(0, 0, 0, 0, 1, 2, 3, 4, 5) .skip(4) .debug(\"skip\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 11:33:49.559: skip -> subscribed 2017-12-27 11:33:49.559: skip -> Event next(1) 2017-12-27 11:33:49.559: skip -> Event next(2) 2017-12-27 11:33:49.559: skip -> Event next(3) 2017-12-27 11:33:49.559: skip -> Event next(4) 2017-12-27 11:33:49.559: skip -> Event next(5) 2017-12-27 11:33:49.559: skip -> Event completed 2017-12-27 11:33:49.559: skip -> isDisposed skipWhile 跳过 Observable 中头几个元素，直到元素的判定为否，闭包返回 true 则跳过(skip)，skipWhile 操作符可以让你忽略源 Observable 中 头几个 元素，直到元素的判定为 false 后，它才镜像源 Observable，一旦有 false 产生，后面的元素不会再进行判断。 eg: func skipWhile() { Observable .of(0, 0, 0, 0, 1, 2, 3, 4, 5, -1, 0, 0, 10) .skipWhile({ (value) -> Bool in return value == 0 }) .debug(\"skipWhile\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 11:35:43.512: skipWhile -> subscribed 2017-12-27 11:35:43.512: skipWhile -> Event next(1) 2017-12-27 11:35:43.512: skipWhile -> Event next(2) 2017-12-27 11:35:43.513: skipWhile -> Event next(3) 2017-12-27 11:35:43.513: skipWhile -> Event next(4) 2017-12-27 11:35:43.513: skipWhile -> Event next(5) 2017-12-27 11:35:43.513: skipWhile -> Event next(-1) 2017-12-27 11:35:43.513: skipWhile -> Event next(0) 2017-12-27 11:35:43.513: skipWhile -> Event next(0) 2017-12-27 11:35:43.513: skipWhile -> Event next(10) 2017-12-27 11:35:43.513: skipWhile -> Event completed 2017-12-27 11:35:43.513: skipWhile -> isDisposed skipUntil 跳过 Observable 中头几个元素，直到另一个 Observable 发出一个元素，skipUntil 操作符可以让你忽略源 Observable 中头几个元素，直到另一个 Observable 发出一个元素后，它才镜像源 Observable。 eg: func skipUntil() { let skipUntilObservable = Observable.create { (observer) -> Disposable in delayTime(3, block: { print(\"skipUntilObservable => onNext(0)\") observer.onNext(0) }) return Disposables.create() } getFirstObservable() .skipUntil(skipUntilObservable) .debug(\"skipUntil\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 12:25:42.199: skipUntil -> subscribed skipUntilObservable => onNext(0) 2017-12-27 12:25:47.199: skipUntil -> Event next(First -> 2|A) 2017-12-27 12:25:47.200: skipUntil -> Event next(First -> 2|B) 2017-12-27 12:25:47.200: skipUntil -> Event next(First -> 2|C) 2017-12-27 12:25:51.201: skipUntil -> Event next(First -> 3|A) 2017-12-27 12:25:51.201: skipUntil -> Event next(First -> 3|B) 2017-12-27 12:25:51.201: skipUntil -> Event next(First -> 3|C) 2017-12-27 12:25:51.201: skipUntil -> Event completed 2017-12-27 12:25:51.201: skipUntil -> isDisposed take 通过 take 操作符你可以只发出头 n 个元素。并且忽略掉后面的元素，直接结束序列。 eg: func take() { Observable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\") .take(3) .debug(\"take\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 12:28:14.822: take -> subscribed 2017-12-27 12:28:14.822: take -> Event next(🐱) 2017-12-27 12:28:14.822: take -> Event next(🐰) 2017-12-27 12:28:14.822: take -> Event next(🐶) 2017-12-27 12:28:14.822: take -> Event completed 2017-12-27 12:28:14.822: take -> isDisposed takeLast 通过 takeLast 操作符你可以只发出尾部 n 个元素。并且忽略掉前面的元素。 在 onCompleted() 之后取出最后n个元素一次性发出。 eg: func takeLast() { getFirstObservable() .takeLast(5) .debug(\"takeLast\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 12:30:13.992: takeLast -> subscribed 2017-12-27 12:30:22.994: takeLast -> Event next(First -> 2|B) 2017-12-27 12:30:22.994: takeLast -> Event next(First -> 2|C) 2017-12-27 12:30:22.994: takeLast -> Event next(First -> 3|A) 2017-12-27 12:30:22.994: takeLast -> Event next(First -> 3|B) 2017-12-27 12:30:22.994: takeLast -> Event next(First -> 3|C) 2017-12-27 12:30:22.995: takeLast -> Event completed 2017-12-27 12:30:22.995: takeLast -> isDisposed takeWhile 镜像一个 Observable 直到某个元素的判定为 false 闭包返回 true 则放行，返回 false 则结束 takeWhile 操作符将镜像源 Observable 直到某个元素的判定为 false。此时，这个镜像的 Observable 将立即终止。 eg: func takeWhile() { Observable .of(0, 0, 0, 0, 1, 2, 3, 4, 5, -1, 0, 0, 10) .takeWhile({ (value) -> Bool in return value >= 0 }) .debug(\"skipWhile\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 12:32:42.491: skipWhile -> subscribed 2017-12-27 12:32:42.492: skipWhile -> Event next(0) 2017-12-27 12:32:42.492: skipWhile -> Event next(0) 2017-12-27 12:32:42.492: skipWhile -> Event next(0) 2017-12-27 12:32:42.492: skipWhile -> Event next(0) 2017-12-27 12:32:42.492: skipWhile -> Event next(1) 2017-12-27 12:32:42.492: skipWhile -> Event next(2) 2017-12-27 12:32:42.492: skipWhile -> Event next(3) 2017-12-27 12:32:42.492: skipWhile -> Event next(4) 2017-12-27 12:32:42.492: skipWhile -> Event next(5) 2017-12-27 12:32:42.492: skipWhile -> Event completed 2017-12-27 12:32:42.492: skipWhile -> isDisposed takeUntil 忽略一部分元素，这些元素是在第二个 Observable 产生事件后发出的(则被忽略)。 takeUntil 操作符将镜像源 Observable，它同时观测第二个 Observable。一旦第二个 Observable 发出一个元素或者产生一个终止事件，那个镜像的 Observable 将立即终止。 eg: func takeUntil() { let takeUntilObservable = Observable.create { (observer) -> Disposable in delayTime(3, block: { print(\"takeUntilObservable => onNext(0)\") observer.onNext(0) }) return Disposables.create() } getFirstObservable() .takeUntil(takeUntilObservable) .debug(\"takeUntil\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 12:36:41.994: takeUntil -> subscribed 2017-12-27 12:36:42.996: takeUntil -> Event next(First -> 1|A) 2017-12-27 12:36:42.996: takeUntil -> Event next(First -> 1|B) 2017-12-27 12:36:42.996: takeUntil -> Event next(First -> 1|C) takeUntilObservable => onNext(0) 2017-12-27 12:36:44.995: takeUntil -> Event completed 2017-12-27 12:36:44.995: takeUntil -> isDisposed single 限制 Observable 只有一个元素，否出发出一个 error 事件，single 操作符将限制 Observable 只产生一个元素。 如果 Observable 只有一个元素，它将镜像这个 Observable 。 如果 Observable 没有元素或者元素数量大于一，它将产生一个 error 事件。 eg: func single() { Observable .just(1) .single() .subscribe({ e in print(\"single 1 => \\(e.debugDescription)\") }) .disposed(by: disposeBag) Observable .of(1, 2, 3, 4, 5) .single() .subscribe({ (e) in print(\"single 2 => \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下： single 1 => next(1) single 1 => completed single 2 => next(1) single 2 => error(Sequence contains more than one element.) "},"RxSwiftStudy/Operator/Combining.html":{"url":"RxSwiftStudy/Operator/Combining.html","title":"7.05 联合 Observable","keywords":"","body":"联合 Observable - Combining Operator startWith startWith 操作符会在 Observable 头部插入一些元素。（如果你想在尾部加入一些元素可以用concat） eg: func startWith() { Observable.of(\"🐶\", \"🐱\", \"🐭\", \"🐹\") .startWith(\"First\") .startWith(\"Second\") .startWith(\"Third\") .startWith(\"1\", \"2\", \"3\") .debug(\"startWith\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 12:42:41.259: startWith -> subscribed 2017-12-27 12:42:41.259: startWith -> Event next(1) 2017-12-27 12:42:41.259: startWith -> Event next(2) 2017-12-27 12:42:41.259: startWith -> Event next(3) 2017-12-27 12:42:41.259: startWith -> Event next(Third) 2017-12-27 12:42:41.259: startWith -> Event next(Second) 2017-12-27 12:42:41.259: startWith -> Event next(First) 2017-12-27 12:42:41.259: startWith -> Event next(🐶) 2017-12-27 12:42:41.259: startWith -> Event next(🐱) 2017-12-27 12:42:41.259: startWith -> Event next(🐭) 2017-12-27 12:42:41.259: startWith -> Event next(🐹) 2017-12-27 12:42:41.260: startWith -> Event completed 2017-12-27 12:42:41.260: startWith -> isDisposed combineLatest combineLatest 操作符将多个 Observables 中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。 这些源 Observables 中任何一个发出一个元素，他都会发出一个元素（前提是，这些 Observables 曾经发出过元素）。 eg: func combineLatest() { Observable .combineLatest(getFirstObservable(), getSecondObservable(), resultSelector: { (fstr, sstr) -> String in return fstr + \" | \" + sstr }) .debug(\"combineLatest\") .subscribe() .disposed(by: disposeBag) } 输出如下 2017-12-27 12:45:26.780: combineLatest -> subscribed 2017-12-27 12:45:27.782: combineLatest -> Event next(First -> 1|A | Second -> 1) 2017-12-27 12:45:27.782: combineLatest -> Event next(First -> 1|B | Second -> 1) 2017-12-27 12:45:27.782: combineLatest -> Event next(First -> 1|C | Second -> 1) 2017-12-27 12:45:30.886: combineLatest -> Event next(First -> 1|C | Second -> 2) 2017-12-27 12:45:31.781: combineLatest -> Event next(First -> 2|A | Second -> 2) 2017-12-27 12:45:31.782: combineLatest -> Event next(First -> 2|B | Second -> 2) 2017-12-27 12:45:31.782: combineLatest -> Event next(First -> 2|C | Second -> 2) 2017-12-27 12:45:34.886: combineLatest -> Event next(First -> 2|C | Second -> 3) 2017-12-27 12:45:35.781: combineLatest -> Event next(First -> 3|A | Second -> 3) 2017-12-27 12:45:35.781: combineLatest -> Event next(First -> 3|B | Second -> 3) 2017-12-27 12:45:35.781: combineLatest -> Event next(First -> 3|C | Second -> 3) 2017-12-27 12:45:35.781: combineLatest -> Event completed 2017-12-27 12:45:35.782: combineLatest -> isDisposed zip 通过一个函数将多个 Observables 的元素组合起来，然后将每一个组合的结果发出来。 zip 操作符将多个(最多不超过8个) Observables 的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。 例如，返回的 Observable 的第一个元素，是由每一个源 Observables 的第一个元素组合出来的。它的第二个元素 ，是由每一个源 Observables 的第二个元素组合出来的。它的第三个元素 ，是由每一个源 Observables 的第三个元素组合出来的，以此类推。 它的元素数量等于源 Observables 中元素数量最少的那个。 eg: func zip() { let disposeBag = DisposeBag() let first = PublishSubject() let second = PublishSubject() Observable .zip(first, second) { $0 + $1 } .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) first.onNext(\"1\") second.onNext(\"A\") first.onNext(\"2\") second.onNext(\"B\") second.onNext(\"C\") second.onNext(\"D\") first.onNext(\"3\") first.onNext(\"4\") first.onNext(\"5\") } 输出如下： 1A 2B 3C 4D withLatestFrom 将两 Observables 最新的元素通过一个函数组合以来，当第一个 Observable 发出一个元素，就将组合后的元素发送出来 withLatestFrom 操作符将两个 Observables 中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。 当第一个 Observable 发出一个元素时，就立即取出第二个 Observable 中最新的元素，通过一个组合函数将两个最新的元素合并后发送出去。 eg: func withLatestFrom() { // 当第一个 Observable 发出一个元素时，就立即取出第二个 Observable 中最新的元素， // 然后把第二个 Observable 中最新的元素发送出去。 print(\"============================First============================\") getFirstObservable() .withLatestFrom(getSecondObservable()) .debug(\"withLatestFrom\") .subscribe() .disposed(by: disposeBag) // 当第一个 Observable 发出一个元素时，就立即取出第二个 Observable 中最新的元素， // 然后把第一个 Observable 中最新的元素first和然后把第二个 Observable 中最新的元素second组合first+second发送出去。 delayTime(10) { print(\"============================Second============================\") self.getFirstObservable() .withLatestFrom(self.getSecondObservable(), resultSelector: { (first, second) -> String in return first + \" \" + second }) .debug(\"withLatestFrom & Function\") .subscribe() .disposed(by: self.disposeBag) } } 输出如下： ============================First============================ 2017-12-27 12:50:16.250: withLatestFrom -> subscribed 2017-12-27 12:50:17.253: withLatestFrom -> Event next(Second -> 1) 2017-12-27 12:50:17.253: withLatestFrom -> Event next(Second -> 1) 2017-12-27 12:50:17.253: withLatestFrom -> Event next(Second -> 1) 2017-12-27 12:50:21.750: withLatestFrom -> Event next(Second -> 2) 2017-12-27 12:50:21.750: withLatestFrom -> Event next(Second -> 2) 2017-12-27 12:50:21.750: withLatestFrom -> Event next(Second -> 2) 2017-12-27 12:50:26.144: withLatestFrom -> Event next(Second -> 3) 2017-12-27 12:50:26.144: withLatestFrom -> Event next(Second -> 3) 2017-12-27 12:50:26.144: withLatestFrom -> Event next(Second -> 3) 2017-12-27 12:50:26.145: withLatestFrom -> Event completed 2017-12-27 12:50:26.145: withLatestFrom -> isDisposed ============================Second============================ 2017-12-27 12:50:26.253: withLatestFrom & Function -> subscribed 2017-12-27 12:50:27.254: withLatestFrom & Function -> Event next(First -> 1|A Second -> 1) 2017-12-27 12:50:27.255: withLatestFrom & Function -> Event next(First -> 1|B Second -> 1) 2017-12-27 12:50:27.255: withLatestFrom & Function -> Event next(First -> 1|C Second -> 1) 2017-12-27 12:50:31.254: withLatestFrom & Function -> Event next(First -> 2|A Second -> 2) 2017-12-27 12:50:31.254: withLatestFrom & Function -> Event next(First -> 2|B Second -> 2) 2017-12-27 12:50:31.254: withLatestFrom & Function -> Event next(First -> 2|C Second -> 2) 2017-12-27 12:50:35.253: withLatestFrom & Function -> Event next(First -> 3|A Second -> 3) 2017-12-27 12:50:35.253: withLatestFrom & Function -> Event next(First -> 3|B Second -> 3) 2017-12-27 12:50:35.253: withLatestFrom & Function -> Event next(First -> 3|C Second -> 3) 2017-12-27 12:50:35.254: withLatestFrom & Function -> Event completed 2017-12-27 12:50:35.254: withLatestFrom & Function -> isDisposed merge 通过使用 merge 操作符你可以将多个 Observables 合并成一个，当某一个 Observable 发出一个元素时，他就将这个元素发出。 如果，某一个 Observable 发出一个 onError 事件，那么被合并的 Observable 也会将它发出，并且立即终止序列。 eg: func merge() { let subject1 = PublishSubject() let subject2 = PublishSubject() Observable.of(subject1, subject2) .merge() .subscribe(onNext: { print($0) }) .disposed(by: disposeBag) subject1.onNext(\"🅰️\") subject1.onNext(\"🅱️\") subject2.onNext(\"1️⃣\") subject2.onNext(\"2️⃣\") subject1.onNext(\"🆎\") subject2.onNext(\"3️⃣\") let err = TError.init(errorCode: 0, errorString: \"Test Error\", errorData: nil) subject1.onError(err) subject2.onNext(\"4️⃣\") subject2.onNext(\"5️⃣\") } 输出如下： 2017-12-27 12:56:10.984: merge -> subscribed 2017-12-27 12:56:10.986: merge -> Event next(🅰️) 2017-12-27 12:56:10.986: merge -> Event next(🅱️) 2017-12-27 12:56:10.987: merge -> Event next(1️⃣) 2017-12-27 12:56:10.987: merge -> Event next(2️⃣) 2017-12-27 12:56:10.987: merge -> Event next(🆎) 2017-12-27 12:56:10.987: merge -> Event next(3️⃣) 2017-12-27 12:56:10.988: merge -> Event error(TError(errorCode: 0, errorString: \"Test Error\", errorData: nil)) Unhandled error happened: TError(errorCode: 0, errorString: \"Test Error\", errorData: nil) subscription called from: 0 RxSwift 0x0000000109fa158c _T07RxSwift14ObservableTypePAAE9subscribeAA10Disposable_py1EQzcSg6onNext_ys5Error_pcSg0gI0yycSg0G9CompletedAM0G8DisposedtF + 780 1 RxSwiftExample 0x0000000109853023 _T011RxSwiftExample8OperatorC5mergeyyF + 1427 2 RxSwiftExample 0x0000000109853884 _T011RxSwiftExample8OperatorC5mergeyyFTo + 36 3 RxSwiftExample 0x0000000109877de1 _T011RxSwiftExample27OperatorTableViewControllerC11viewDidLoadyyFy10Foundation9IndexPathVcfU1_ + 897 4 RxSwiftExample 0x0000000109877f17 _T011RxSwiftExample27OperatorTableViewControllerC11viewDidLoadyyFy10Foundation9IndexPathVcfU1_TA + 103 5 RxSwiftExample 0x0000000109838da0 _T010Foundation9IndexPathVIxx_ACIxi_TR + 48 6 RxSwiftExample 0x0000000109877fa2 _T010Foundation9IndexPathVIxx_ACIxi_TRTA + 66 7 RxSwift 0x0000000109fa1d35 _T07RxSwift14ObservableTypePAAE9subscribeAA10Disposable_py1EQzcSg6onNext_ys5Error_pcSg0gI0yycSg0G9CompletedAM0G8DisposedtFyAA5EventOyAGGcfU_ + 885 8 RxSwift 0x0000000109fa228a _T07RxSwift14ObservableTypePAAE9subscribeAA10Disposable_py1EQzcSg6onNext_ys5Error_pcSg0gI0yycSg0G9CompletedAM0G8DisposedtFyAA5EventOyAGGcfU_TA + 282 9 RxSwift 0x0000000109ed7998 _T07RxSwift17AnonymousObserverC6onCoreyAA5EventOyxGF + 408 10 RxSwift 0x0000000109fa9026 _T07RxSwift12ObserverBaseC2onyAA5EventOyxGF + 742 11 RxSwift 0x0000000109fa95be _T07RxSwift12ObserverBaseCyxGAA0C4TypeAAlAaEP2onyAA5EventOy1EQzGFTW + 62 12 RxSwift 0x0000000109ed8c93 _T0TA + 115 13 RxSwift 0x0000000109ee33a7 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTR + 23 14 RxSwift 0x0000000109ff5bc6 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTRTA.47 + 118 15 RxSwift 0x0000000109ee3770 _T07RxSwift5EventOyxGytIxir_ADIxi_lTR + 16 16 RxSwift 0x0000000109ee5332 _T07RxSwift5EventOyxGytIxir_ADIxi_lTRTA.18 + 82 17 RxSwift 0x0000000109ee4564 _T07RxSwift8dispatchyAA3BagVyyAA5EventOyxGcG_AGtlF + 900 18 RxSwift 0x0000000109fef92e _T07RxSwift36ShareReplay1WhileConnectedConnection33_E9FE621655D67A613BF2FC2D9B3041FCLLC2onyAA5EventOyxGF + 1230 19 RxSwift 0x0000000109ff1aeb _T07RxSwift36ShareReplay1WhileConnectedConnection33_E9FE621655D67A613BF2FC2D9B3041FCLLCyxGAA12ObserverTypeAAlAaFP2onyAA5EventOy1EQzGFTW + 43 20 RxSwift 0x0000000109ffdbcc _T07RxSwift4SinkC9forwardOnyAA5EventOy1EQzGF + 780 21 RxSwift 0x0000000109ef5ff7 _T07RxSwift9CatchSink33_7E15DB08AB19A7B882D5C92A393C6F6DLLC2onyAA5EventOy1EQzGF + 823 22 RxSwift 0x0000000109ef6a5b _T07RxSwift9CatchSink33_7E15DB08AB19A7B882D5C92A393C6F6DLLCyxGAA12ObserverTypeA2aFRzlAaFP2onyAA5EventOy1EQzGFTW + 43 23 RxSwift 0x0000000109fa6f11 _T07RxSwift32ObserveOnSerialDispatchQueueSink33_277A93ABA8477198C125F3F26B2D4B62LLCADyxGAA0efG9SchedulerC9scheduler_x8observerAA10Cancelable_p6canceltcfcAA10Disposable_pAE4sink_AA5EventOy1EQzG5eventtcfU_ + 833 24 RxSwift 0x0000000109fa8579 _T07RxSwift32ObserveOnSerialDispatchQueueSink33_277A93ABA8477198C125F3F26B2D4B62LLCADyxGAA0efG9SchedulerC9scheduler_x8observerAA10Cancelable_p6canceltcfcAA10Disposable_pAE4sink_AA5EventOy1EQzG5eventtcfU_TA + 9 25 RxSwift 0x0000000109fa77d9 _T07RxSwift32ObserveOnSerialDispatchQueueSink33_277A93ABA8477198C125F3F26B2D4B62LLCyxGAA5EventOy1EQzGAA10Disposable_pIxxir_AE_AJtAaK_pIxir_AA12ObserverTypeRzlTR + 137 26 RxSwift 0x0000000109fa8786 _T07RxSwift32ObserveOnSerialDispatchQueueSink33_277A93ABA8477198C125F3F26B2D4B62LLCyxGAA5EventOy1EQzGAA10Disposable_pIxxir_AE_AJtAaK_pIxir_AA12ObserverTypeRzlTRTA + 102 27 RxSwift 0x0000000109f80564 _T07RxSwift13MainSchedulerC16scheduleInternalAA10Disposable_px_AaE_pxc6actiontlF + 484 28 RxSwift 0x0000000109feca4d _T07RxSwift28SerialDispatchQueueSchedulerC8scheduleAA10Disposable_px_AaE_pxc6actiontlF + 173 29 RxSwift 0x0000000109fa76cc _T07RxSwift32ObserveOnSerialDispatchQueueSink33_277A93ABA8477198C125F3F26B2D4B62LLC6onCoreyAA5EventOy1EQzGF + 1148 30 RxSwift 0x0000000109fa9026 _T07RxSwift12ObserverBaseC2onyAA5EventOyxGF + 742 31 RxSwift 0x0000000109fa95be _T07RxSwift12ObserverBaseCyxGAA0C4TypeAAlAaEP2onyAA5EventOy1EQzGFTW + 62 32 RxSwift 0x0000000109ffdbcc _T07RxSwift4SinkC9forwardOnyAA5EventOy1EQzGF + 780 33 RxSwift 0x000000010a0080e0 _T07RxSwift15SubscribeOnSink33_B44C3DD7F62EF81799E6347E59A266A2LLC2onyAA5EventOy1EQzGF + 400 34 RxSwift 0x000000010a008e0b _T07RxSwift15SubscribeOnSink33_B44C3DD7F62EF81799E6347E59A266A2LLCyxq_GAA12ObserverTypeA2A010ObservableP0RzAaFR_1EQy_AHRtzr0_lAaFP2onyAA5EventOyAHQzGFTW + 43 35 RxSwift 0x0000000109ffdbcc _T07RxSwift4SinkC9forwardOnyAA5EventOy1EQzGF + 780 36 RxSwift 0x0000000109f81695 _T07RxSwift7MapSink33_5428EFA9A9B0C0340021B871D2E5AC01LLC2onyAA5EventOyxGF + 1093 37 RxSwift 0x0000000109f81beb _T07RxSwift7MapSink33_5428EFA9A9B0C0340021B871D2E5AC01LLCyxq_GAA12ObserverTypeA2aFR_r0_lAaFP2onyAA5EventOy1EQzGFTW + 43 38 RxSwift 0x0000000109ffdbcc _T07RxSwift4SinkC9forwardOnyAA5EventOy1EQzGF + 780 39 RxSwift 0x000000010a0080e0 _T07RxSwift15SubscribeOnSink33_B44C3DD7F62EF81799E6347E59A266A2LLC2onyAA5EventOy1EQzGF + 400 40 RxSwift 0x000000010a008e0b _T07RxSwift15SubscribeOnSink33_B44C3DD7F62EF81799E6347E59A266A2LLCyxq_GAA12ObserverTypeA2A010ObservableP0RzAaFR_1EQy_AHRtzr0_lAaFP2onyAA5EventOyAHQzGFTW + 43 41 RxSwift 0x0000000109ed8c93 _T0TA + 115 42 RxSwift 0x0000000109ee33a7 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTR + 23 43 RxSwift 0x0000000109ff5a36 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTRTA + 118 44 RxSwift 0x0000000109ee3770 _T07RxSwift5EventOyxGytIxir_ADIxi_lTR + 16 45 RxSwift 0x0000000109ee5332 _T07RxSwift5EventOyxGytIxir_ADIxi_lTRTA.18 + 82 46 RxSwift 0x0000000109ee4564 _T07RxSwift8dispatchyAA3BagVyyAA5EventOyxGcG_AGtlF + 900 47 RxSwift 0x0000000109ff2eee _T07RxSwift29ShareWhileConnectedConnection33_E9FE621655D67A613BF2FC2D9B3041FCLLC2onyAA5EventOyxGF + 1230 48 RxSwift 0x0000000109ff4abb _T07RxSwift29ShareWhileConnectedConnection33_E9FE621655D67A613BF2FC2D9B3041FCLLCyxGAA12ObserverTypeAAlAaFP2onyAA5EventOy1EQzGFTW + 43 49 RxSwift 0x0000000109ffdbcc _T07RxSwift4SinkC9forwardOnyAA5EventOy1EQzGF + 780 50 RxSwift 0x0000000109f66dfb _T07RxSwift6DoSink33_51F9E615740E91B2E920965FFBB1EED3LLC2onyAA5EventOy1EQzGF + 843 51 RxSwift 0x0000000109f674eb _T07RxSwift6DoSink33_51F9E615740E91B2E920965FFBB1EED3LLCyxGAA12ObserverTypeA2aFRzlAaFP2onyAA5EventOy1EQzGFTW + 43 52 RxSwift 0x0000000109ed8c93 _T0TA + 115 53 RxSwift 0x0000000109ee33a7 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTR + 23 54 RxSwift 0x0000000109fbd396 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTRTA + 118 55 RxSwift 0x0000000109ee3770 _T07RxSwift5EventOyxGytIxir_ADIxi_lTR + 16 56 RxSwift 0x0000000109ee5332 _T07RxSwift5EventOyxGytIxir_ADIxi_lTRTA.18 + 82 57 RxSwift 0x0000000109ee4564 _T07RxSwift8dispatchyAA3BagVyyAA5EventOyxGcG_AGtlF + 900 58 RxSwift 0x0000000109fbb1ca _T07RxSwift14PublishSubjectC2onyAA5EventOyxGF + 1018 59 RxCocoa 0x0000000109c6cd91 _T07RxSwift14PublishSubjectC2onyAA5EventOyxGFTA + 17 60 RxCocoa 0x0000000109c6c46d _T07RxSwift5EventOySayypGGIxi_AEIxx_TR + 29 61 RxCocoa 0x0000000109c6cd6e _T07RxSwift5EventOySayypGGIxi_AEIxx_TRTA + 78 62 RxCocoa 0x0000000109c6a5eb _T07RxCocoa13DelegateProxyC14_methodInvokedy10ObjectiveC8SelectorV_SayypG13withArgumentstF + 283 63 RxCocoa 0x0000000109c6a664 _T07RxCocoa13DelegateProxyC14_methodInvokedy10ObjectiveC8SelectorV_SayypG13withArgumentstFTo + 84 64 RxCocoa 0x0000000109c3b588 -[_RXDelegateProxy forwardInvocation:] + 536 65 CoreFoundation 0x000000010dee1cd8 ___forwarding___ + 760 66 CoreFoundation 0x000000010dee1958 _CF_forwarding_prep_0 + 120 67 UIKit 0x000000010b309839 -[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] + 1810 68 UIKit 0x000000010b309a54 -[UITableView _userSelectRowAtPendingSelectionIndexPath:] + 344 69 UIKit 0x000000010b1d2d59 _runAfterCACommitDeferredBlocks + 318 70 UIKit 0x000000010b1c1bb1 _cleanUpAfterCAFlushAndRunDeferredBlocks + 280 71 UIKit 0x000000010b1f10e0 _afterCACommitHandler + 137 72 CoreFoundation 0x000000010df01c07 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23 73 CoreFoundation 0x000000010df01b5e __CFRunLoopDoObservers + 430 74 CoreFoundation 0x000000010dee6124 __CFRunLoopRun + 1572 75 CoreFoundation 0x000000010dee5889 CFRunLoopRunSpecific + 409 76 GraphicsServices 0x00000001136149c6 GSEventRunModal + 62 77 UIKit 0x000000010b1c75d6 UIApplicationMain + 159 78 RxSwiftExample 0x0000000109858c07 main + 55 79 libdyld.dylib 0x000000010f7bcd81 start + 1 80 ??? 0x0000000000000001 0x0 + 1 2017-12-27 12:56:10.991: merge -> isDisposed switchLatest 当你的事件序列是一个事件序列的序列 (Observable>) 的时候，（可以理解成二维序列） 可以使用 switch 将序列的序列平铺成一维，并且在出现新的序列的时候，自动切换到最新的那个序列上。 和 merge 相似的是，它也是起到了将多个序列拍平成一条序列的作用。 ⚠️注意：当源 Observable 发出一个新的 Observable 时，而不是当新的 Observable 发出一个项目时，它将从之前发出的Observable中取消订阅。 这意味着在后面的 Observable 被发射的时间和随后的 Observable 本身开始发射的时间之间，前一个 Observable 发射的物体将被丢弃。 eg: func switchLatest() { // 第一个： 发送3个元素 let innerObservable_1 = Observable.of(\"innerObservable_1: 1\", \"innerObservable_1: 2\", \"innerObservable_1: 3\") // 持续1秒发出一个元素，递增 let innerObservable_2 = Observable.interval(1, scheduler: MainScheduler.instance).map { (value) -> String in print(\"innerObservable_2 => Send \\(value)\") return \"innerObservable_2: \\(value)\" } // 持续1秒发出一个元素，递增 let innerObservable_3 = Observable.interval(1, scheduler: MainScheduler.instance).map { (value) -> String in print(\"innerObservable_3 => Send \\(value)\") return \"innerObservable_3: \\(value)\" } let externalObservable = Observable>.create({ (observer) -> Disposable in observer.onNext(innerObservable_1) delayTime(2, block: { observer.onNext(innerObservable_2) }) delayTime(6, block: { observer.onNext(innerObservable_3) }) delayTime(12, block: { // 不加 observer.onNext(Observable.never()) 的话，innerObservable_3会持续不断的发送 print(\"observer.onNext(Observable.never())\") print(\"observer.onCompleted()\") observer.onNext(Observable.never()) observer.onCompleted() }) return Disposables.create() }) externalObservable .switchLatest() .debug(\"switchLatest\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 12:59:48.877: switchLatest -> subscribed 2017-12-27 12:59:48.878: switchLatest -> Event next(innerObservable_1: 1) 2017-12-27 12:59:48.878: switchLatest -> Event next(innerObservable_1: 2) 2017-12-27 12:59:48.878: switchLatest -> Event next(innerObservable_1: 3) innerObservable_2 => Send 0 2017-12-27 12:59:51.880: switchLatest -> Event next(innerObservable_2: 0) innerObservable_2 => Send 1 2017-12-27 12:59:52.881: switchLatest -> Event next(innerObservable_2: 1) innerObservable_2 => Send 2 2017-12-27 12:59:53.881: switchLatest -> Event next(innerObservable_2: 2) innerObservable_3 => Send 0 2017-12-27 12:59:55.879: switchLatest -> Event next(innerObservable_3: 0) innerObservable_3 => Send 1 2017-12-27 12:59:56.879: switchLatest -> Event next(innerObservable_3: 1) innerObservable_3 => Send 2 2017-12-27 12:59:57.878: switchLatest -> Event next(innerObservable_3: 2) innerObservable_3 => Send 3 2017-12-27 12:59:58.879: switchLatest -> Event next(innerObservable_3: 3) innerObservable_3 => Send 4 2017-12-27 12:59:59.878: switchLatest -> Event next(innerObservable_3: 4) observer.onNext(Observable.never()) observer.onCompleted() "},"RxSwiftStudy/Operator/ErrorHandling.html":{"url":"RxSwiftStudy/Operator/ErrorHandling.html","title":"7.06 错误处理操作符","keywords":"","body":"错误处理操作符 - ErrorHandling Operator catchError catchError 操作符将会拦截一个 error 事件，将它替换成其他的元素或者一组元素，然后传递给观察者。这样可以使得 Observable 正常结束，或者根本都不需要结束。 eg: func catchError() { let recoverObservable = Observable.just(\"Recover Error\") getErrorObservable() .catchError({ (error) -> Observable in print(\"\\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\") error.printLog() print(\" 输出如下： 2017-12-27 13:50:58.068: catchError -> subscribed 2017-12-27 13:50:59.070: catchError -> Event next(1️⃣) 2017-12-27 13:51:00.070: catchError -> Event next(2️⃣) >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 10 Test Event next(Recover Error) 2017-12-27 13:51:01.070: catchError -> Event completed 2017-12-27 13:51:01.070: catchError -> isDisposed catchErrorJustReturn catchErrorJustReturn 操作符会将 error 事件替换成其他的一个元素，然后结束该序列。 eg: func catchErrorJustReturn() { getErrorObservable() .catchErrorJustReturn(\"Recover Error\") .debug(\"catchErrorJustReturn\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 13:53:16.850: catchErrorJustReturn -> subscribed 2017-12-27 13:53:17.854: catchErrorJustReturn -> Event next(1️⃣) 2017-12-27 13:53:18.852: catchErrorJustReturn -> Event next(2️⃣) 2017-12-27 13:53:19.854: catchErrorJustReturn -> Event next(Recover Error) 2017-12-27 13:53:19.854: catchErrorJustReturn -> Event completed 2017-12-27 13:53:19.854: catchErrorJustReturn -> isDisposed retry 如果源 Observable 产生一个错误事件，重新对它进行订阅，希望它不会再次产生错误 retry 操作符将不会将 error 事件，传递给观察者。 然而，它会从新订阅源 Observable，给这个 Observable 一个重试的机会，让它有机会不产生 error 事件。 retry 总是对观察者发出 next 事件，即便源序列产生了一个 error 事件，所以这样可能会产生重复的元素。 func retry() { let observable = Observable.create { (observer) -> Disposable in if arc4random() % 10 == 0 { observer.onNext(1) } else { let error = TError.init(errorCode: 10, errorString: \"Random Error\", errorData: nil) observer.onError(error) } return Disposables.create() } observable .debug(\"Befor Retry\") .retry() .debug(\"After Retry\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 13:56:42.068: After Retry -> subscribed 2017-12-27 13:56:42.068: Befor Retry -> subscribed 2017-12-27 13:56:42.068: Befor Retry -> Event error(TError(errorCode: 10, errorString: \"Random Error\", errorData: nil)) 2017-12-27 13:56:42.068: Befor Retry -> isDisposed 2017-12-27 13:56:42.068: Befor Retry -> subscribed 2017-12-27 13:56:42.068: Befor Retry -> Event error(TError(errorCode: 10, errorString: \"Random Error\", errorData: nil)) 2017-12-27 13:56:42.069: Befor Retry -> isDisposed 2017-12-27 13:56:42.069: Befor Retry -> subscribed 2017-12-27 13:56:42.069: Befor Retry -> Event error(TError(errorCode: 10, errorString: \"Random Error\", errorData: nil)) 2017-12-27 13:56:42.069: Befor Retry -> isDisposed 2017-12-27 13:56:42.069: Befor Retry -> subscribed 2017-12-27 13:56:42.069: Befor Retry -> Event error(TError(errorCode: 10, errorString: \"Random Error\", errorData: nil)) 2017-12-27 13:56:42.069: Befor Retry -> isDisposed 2017-12-27 13:56:42.069: Befor Retry -> subscribed 2017-12-27 13:56:42.069: Befor Retry -> Event error(TError(errorCode: 10, errorString: \"Random Error\", errorData: nil)) 2017-12-27 13:56:42.069: Befor Retry -> isDisposed 2017-12-27 13:56:42.069: Befor Retry -> subscribed 2017-12-27 13:56:42.069: Befor Retry -> Event error(TError(errorCode: 10, errorString: \"Random Error\", errorData: nil)) 2017-12-27 13:56:42.069: Befor Retry -> isDisposed 2017-12-27 13:56:42.069: Befor Retry -> subscribed 2017-12-27 13:56:42.070: Befor Retry -> Event next(1) 2017-12-27 13:56:42.070: After Retry -> Event next(1) retryWhen 这个操作符主要描述应该在何时重试，并且通过闭包里面返回的 Observable 来控制重试的时机： 闭包里面的参数是 Observable 也就是所产生错误的序列，然后返回值是一个 Observable。 当这个返回的 Observable 发出一个元素时，就进行重试操作。 当它发出一个 error 或者 completed 事件时，就不会重试，并且将这个事件传递给到后面的观察者。 func retryWhen() { let observable = Observable.create { (observer) -> Disposable in if arc4random() % 10 == 0 { observer.onNext(1) } else { let error = TError.init(errorCode: 10, errorString: \"Random Error\", errorData: nil) observer.onError(error) } return Disposables.create() } let retryDelay: RxTimeInterval = 1.0 let maxRetryCount: Int = 4 observable .debug(\"Befor RetryWhen\") .retryWhen({ (rxError) -> Observable in return rxError.enumerated().flatMap({ (index, element) -> Observable in if index >= maxRetryCount { let err = TError.init(errorCode: 0, errorString: \"Retry Too Many Times\", errorData: nil) return Observable.error(err) } return Observable.timer(retryDelay, scheduler: MainScheduler.instance) }) }) .debug(\"After RetryWhen\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 13:59:37.270: After RetryWhen -> subscribed 2017-12-27 13:59:37.270: Befor RetryWhen -> subscribed 2017-12-27 13:59:37.270: Befor RetryWhen -> Event error(TError(errorCode: 10, errorString: \"Random Error\", errorData: nil)) 2017-12-27 13:59:37.271: Befor RetryWhen -> isDisposed 2017-12-27 13:59:38.271: Befor RetryWhen -> subscribed 2017-12-27 13:59:38.272: Befor RetryWhen -> Event error(TError(errorCode: 10, errorString: \"Random Error\", errorData: nil)) 2017-12-27 13:59:38.272: Befor RetryWhen -> isDisposed 2017-12-27 13:59:39.273: Befor RetryWhen -> subscribed 2017-12-27 13:59:39.273: Befor RetryWhen -> Event next(1) 2017-12-27 13:59:39.273: After RetryWhen -> Event next(1) "},"RxSwiftStudy/Operator/Conditional_and_Boolean.html":{"url":"RxSwiftStudy/Operator/Conditional_and_Boolean.html","title":"7.07 条件和 Bool 操作符","keywords":"","body":"条件和 Bool 操作符 - Conditional and Boolean Operator amb 当你传入多个 Observables 到 amb 操作符时 它将取其中一个 Observable：第一个产生事件的那个 Observable，可以是一个 next，error 或者 completed 事件。amb 将忽略掉其他的 Observables。 eg: func amb() { let first = getFirstObservable() let second = getSecondObservable() let third = getThirdObservable() first .amb(second) .amb(third) .debug() .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 14:25:27.276: amb -> subscribed 2017-12-27 14:25:27.388: amb -> Event next(Second -> 1) 2017-12-27 14:25:31.390: amb -> Event next(Second -> 2) 2017-12-27 14:25:35.388: amb -> Event next(Second -> 3) 2017-12-27 14:25:35.388: amb -> Event completed 2017-12-27 14:25:35.388: amb -> isDisposed skipWhile 跳过 Observable 中头几个元素，直到元素的判定为否，闭包返回 true 则跳过(skip)，skipWhile 操作符可以让你忽略源 Observable 中 头几个 元素，直到元素的判定为 false 后，它才镜像源 Observable，一旦有 false 产生，后面的元素不会再进行判断。 eg: func skipWhile() { Observable .of(0, 0, 0, 0, 1, 2, 3, 4, 5, -1, 0, 0, 10) .skipWhile({ (value) -> Bool in return value == 0 }) .debug(\"skipWhile\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 11:35:43.512: skipWhile -> subscribed 2017-12-27 11:35:43.512: skipWhile -> Event next(1) 2017-12-27 11:35:43.512: skipWhile -> Event next(2) 2017-12-27 11:35:43.513: skipWhile -> Event next(3) 2017-12-27 11:35:43.513: skipWhile -> Event next(4) 2017-12-27 11:35:43.513: skipWhile -> Event next(5) 2017-12-27 11:35:43.513: skipWhile -> Event next(-1) 2017-12-27 11:35:43.513: skipWhile -> Event next(0) 2017-12-27 11:35:43.513: skipWhile -> Event next(0) 2017-12-27 11:35:43.513: skipWhile -> Event next(10) 2017-12-27 11:35:43.513: skipWhile -> Event completed 2017-12-27 11:35:43.513: skipWhile -> isDisposed skipUntil 跳过 Observable 中头几个元素，直到另一个 Observable 发出一个元素，skipUntil 操作符可以让你忽略源 Observable 中头几个元素，直到另一个 Observable 发出一个元素后，它才镜像源 Observable。 eg: func skipUntil() { let skipUntilObservable = Observable.create { (observer) -> Disposable in delayTime(3, block: { print(\"skipUntilObservable => onNext(0)\") observer.onNext(0) }) return Disposables.create() } getFirstObservable() .skipUntil(skipUntilObservable) .debug(\"skipUntil\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 12:25:42.199: skipUntil -> subscribed skipUntilObservable => onNext(0) 2017-12-27 12:25:47.199: skipUntil -> Event next(First -> 2|A) 2017-12-27 12:25:47.200: skipUntil -> Event next(First -> 2|B) 2017-12-27 12:25:47.200: skipUntil -> Event next(First -> 2|C) 2017-12-27 12:25:51.201: skipUntil -> Event next(First -> 3|A) 2017-12-27 12:25:51.201: skipUntil -> Event next(First -> 3|B) 2017-12-27 12:25:51.201: skipUntil -> Event next(First -> 3|C) 2017-12-27 12:25:51.201: skipUntil -> Event completed 2017-12-27 12:25:51.201: skipUntil -> isDisposed takeWhile 镜像一个 Observable 直到某个元素的判定为 false 闭包返回 true 则放行，返回 false 则结束 takeWhile 操作符将镜像源 Observable 直到某个元素的判定为 false。此时，这个镜像的 Observable 将立即终止。 eg: func takeWhile() { Observable .of(0, 0, 0, 0, 1, 2, 3, 4, 5, -1, 0, 0, 10) .takeWhile({ (value) -> Bool in return value >= 0 }) .debug(\"takeWhile\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 12:32:42.491: takeWhile -> subscribed 2017-12-27 12:32:42.492: takeWhile -> Event next(0) 2017-12-27 12:32:42.492: takeWhile -> Event next(0) 2017-12-27 12:32:42.492: takeWhile -> Event next(0) 2017-12-27 12:32:42.492: takeWhile -> Event next(0) 2017-12-27 12:32:42.492: takeWhile -> Event next(1) 2017-12-27 12:32:42.492: takeWhile -> Event next(2) 2017-12-27 12:32:42.492: takeWhile -> Event next(3) 2017-12-27 12:32:42.492: takeWhile -> Event next(4) 2017-12-27 12:32:42.492: takeWhile -> Event next(5) 2017-12-27 12:32:42.492: takeWhile -> Event completed 2017-12-27 12:32:42.492: takeWhile -> isDisposed takeUntil 忽略一部分元素，这些元素是在第二个 Observable 产生事件后发出的(则被忽略)。 takeUntil 操作符将镜像源 Observable，它同时观测第二个 Observable。一旦第二个 Observable 发出一个元素或者产生一个终止事件，那个镜像的 Observable 将立即终止。 eg: func takeUntil() { let takeUntilObservable = Observable.create { (observer) -> Disposable in delayTime(3, block: { print(\"takeUntilObservable => onNext(0)\") observer.onNext(0) }) return Disposables.create() } getFirstObservable() .takeUntil(takeUntilObservable) .debug(\"takeUntil\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 12:36:41.994: takeUntil -> subscribed 2017-12-27 12:36:42.996: takeUntil -> Event next(First -> 1|A) 2017-12-27 12:36:42.996: takeUntil -> Event next(First -> 1|B) 2017-12-27 12:36:42.996: takeUntil -> Event next(First -> 1|C) takeUntilObservable => onNext(0) 2017-12-27 12:36:44.995: takeUntil -> Event completed 2017-12-27 12:36:44.995: takeUntil -> isDisposed "},"RxSwiftStudy/Operator/Mathematical_and_Aggregate.html":{"url":"RxSwiftStudy/Operator/Mathematical_and_Aggregate.html","title":"7.08 数学和聚合操作符","keywords":"","body":"数学和聚合操作符 - Mathematical and Aggregate Operator concat concat 操作符将多个 Observables 按顺序串联起来，当前一个 Observable 元素发送完毕后，后一个 Observable 才可以开始发出元素。 concat 将等待前一个 Observable 产生完成事件后，才对后一个 Observable 进行订阅。 如果后一个是热 Observable ，在它前一个 Observable 产生完成事件前，所产生的元素将不会被发送出来。 关于 热Observable 和 冷Observable 可以参考下面的文档 官方文档 Hot Observable和Cold Observable eg: func concat() { getFirstObservable() .concat(getSecondObservable()) .concat(getThirdObservable()) .debug(\"concat\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 14:56:25.556: concat -> subscribed 2017-12-27 14:56:26.558: concat -> Event next(First -> 1|A) 2017-12-27 14:56:26.558: concat -> Event next(First -> 1|B) 2017-12-27 14:56:26.558: concat -> Event next(First -> 1|C) 2017-12-27 14:56:30.558: concat -> Event next(First -> 2|A) 2017-12-27 14:56:30.558: concat -> Event next(First -> 2|B) 2017-12-27 14:56:30.558: concat -> Event next(First -> 2|C) 2017-12-27 14:56:34.558: concat -> Event next(First -> 3|A) 2017-12-27 14:56:34.558: concat -> Event next(First -> 3|B) 2017-12-27 14:56:34.558: concat -> Event next(First -> 3|C) 2017-12-27 14:56:34.659: concat -> Event next(Second -> 1) 2017-12-27 14:56:38.660: concat -> Event next(Second -> 2) 2017-12-27 14:56:42.659: concat -> Event next(Second -> 3) 2017-12-27 14:56:42.764: concat -> Event next(Third -> 1) 2017-12-27 14:56:42.764: concat -> Event next(Third -> 2) 2017-12-27 14:56:42.764: concat -> Event next(Third -> 3) 2017-12-27 14:56:42.764: concat -> Event completed 2017-12-27 14:56:42.764: concat -> isDisposed reduce 持续的将 Observable 的每一个元素应用一个函数，然后发出最终结果。 reduce 操作符将对第一个元素应用一个函数。然后，将结果作为参数填入到第二个元素的应用函数中。以此类推，直到遍历完全部的元素后发出最终结果。 这种操作符在其他地方有时候被称作是 accumulator，aggregate，compress，fold 或者 inject。 与 scan 类似，reduce 发送最终结果，scan 发送每个步骤 eg: func reduce() { let observable = Observable.of(1, 2, 3, 4, 5, 6) // reduce(_ seed:accumulator:) // seed: 基数，accumulator: 运算方法 // // reduce(_ seed:accumulator:mapResult:) // seed: 基数，accumulator: 运算方法，mapResult: 转换返回值 observable .reduce(10, accumulator: {(a, b) -> Int in return a*b }, mapResult: { (value) -> String in return \"In the end, value is \\(value)\" }) .subscribe({ (e) in print(e) }) .disposed(by: disposeBag) } 输出如下： next(In the end, value is 7200) completed "},"RxSwiftStudy/Operator/Connectable.html":{"url":"RxSwiftStudy/Operator/Connectable.html","title":"7.09 连接 Observable 操作符","keywords":"","body":"连接 Observable 操作符 - Connectable Operator multicast multicast()需要传入一个 subject，通过 subject 来管理向订阅者发送消息 eg: func multicast() { let subject = PublishSubject() subject .subscribe(onNext: { print(\"Subject: \\($0)\") }) .disposed(by: disposeBag) let intSequence = Observable .interval(1, scheduler: MainScheduler.instance) .multicast(subject) // 与下面相同： // .multicast(makeSubject: { () -> PublishSubject in // return subject // }) intSequence .subscribe(onNext: { print(\"\\t Subscription 1:, Event: \\($0)\") }) .disposed(by: disposeBag) delayTime(2, block: { intSequence.connect().disposed(by: self.disposeBag) }) delayTime(4, block: { intSequence .subscribe(onNext: { print(\"\\t Subscription 2:, Event: \\($0)\") }) .disposed(by: self.disposeBag) }) delayTime(6, block: { intSequence .subscribe(onNext: { print(\"\\t Subscription 3:, Event: \\($0)\") }) .disposed(by: self.disposeBag) }) } 输出如下： Subject: 0 Subscription 1:, Event: 0 Subject: 1 Subscription 1:, Event: 1 Subscription 2:, Event: 1 Subject: 2 Subscription 1:, Event: 2 Subscription 2:, Event: 2 Subject: 3 Subscription 1:, Event: 3 Subscription 2:, Event: 3 Subscription 3:, Event: 3 Subject: 4 Subscription 1:, Event: 4 Subscription 2:, Event: 4 Subscription 3:, Event: 4 Subject: 5 Subscription 1:, Event: 5 Subscription 2:, Event: 5 Subscription 3:, Event: 5 Subject: 6 Subscription 1:, Event: 6 Subscription 2:, Event: 6 Subscription 3:, Event: 6 Subject: 7 Subscription 1:, Event: 7 Subscription 2:, Event: 7 Subscription 3:, Event: 7 ........... ........... publish 将 Observable 转换为可被连接的 Observable，publish 会将 Observable 转换为可被连接的 Observable。 可被连接的 Observable 和普通的 Observable 十分相似，不过在被订阅后不会发出元素，直到 connect 操作符被应用为止。这样一来你可以控制 Observable 在什么时候开始发出元素。 eg: func publish() { let connectObservable = Observable.of(1, 2, 3, 4, 5, 6).publish() print(\"> connectObservable subscribe now\") connectObservable .subscribe({ e in print(\"connectObservable => \\(e.debugDescription)\") }) .disposed(by: disposeBag) delayTime(3) { print(\"> connectObservable connect now\") connectObservable .connect() .disposed(by: self.disposeBag) } } 输出如下： > connectObservable subscribe now > connectObservable connect now connectObservable => next(1) connectObservable => next(2) connectObservable => next(3) connectObservable => next(4) connectObservable => next(5) connectObservable => next(6) connectObservable => completed connect 通知可被连接的 Observable 可以开始发出元素了，可被连接的 Observable 和普通的 Observable 十分相似，不过在被订阅后不会发出元素，直到 connect 操作符被应用为止。 这样一来你可以等所有观察者全部订阅完成后，才发出元素。 eg: func connect() { let connectableObservable = ConnectableObservable .create({ (observer) -> Disposable in observer.onNext(\"ConnectableObservable -> 1\") observer.onNext(\"ConnectableObservable -> 2\") observer.onNext(\"ConnectableObservable -> 3\") delayTime(2, block: { observer.onNext(\"ConnectableObservable -> delay -> 1\") }) delayTime(4, block: { observer.onNext(\"ConnectableObservable -> delay -> 2\") observer.onCompleted() }) return Disposables.create() }) .publish() connectableObservable .subscribe({ (e) in print(\"First Subscribe : \\(e.debugDescription)\") }) .disposed(by: disposeBag) connectableObservable .connect() .disposed(by: disposeBag) connectableObservable .subscribe({ (e) in print(\"Second Subscribe : \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下： First Subscribe : next(ConnectableObservable -> 1) First Subscribe : next(ConnectableObservable -> 2) First Subscribe : next(ConnectableObservable -> 3) First Subscribe : next(ConnectableObservable -> delay -> 1) Second Subscribe : next(ConnectableObservable -> delay -> 1) First Subscribe : next(ConnectableObservable -> delay -> 2) Second Subscribe : next(ConnectableObservable -> delay -> 2) First Subscribe : completed Second Subscribe : completed refCount 将可被连接的 Observable 转换为普通 Observable，refCount 操作符将自动连接和断开可被连接的 Observable。 当第一个观察者对它订阅时，那么底层的 Observable 将被连接。 当最后一个观察者离开时，那么底层的 Observable 将被断开连接。 eg: func refCount() { let connectObservable = getFirstObservable().publish() let observable = connectObservable.refCount() observable .debug(\"refCount\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 15:11:42.966: refCount -> subscribed 2017-12-27 15:11:43.968: refCount -> Event next(First -> 1|A) 2017-12-27 15:11:43.968: refCount -> Event next(First -> 1|B) 2017-12-27 15:11:43.968: refCount -> Event next(First -> 1|C) 2017-12-27 15:11:47.968: refCount -> Event next(First -> 2|A) 2017-12-27 15:11:47.968: refCount -> Event next(First -> 2|B) 2017-12-27 15:11:47.968: refCount -> Event next(First -> 2|C) 2017-12-27 15:11:51.968: refCount -> Event next(First -> 3|A) 2017-12-27 15:11:51.968: refCount -> Event next(First -> 3|B) 2017-12-27 15:11:51.968: refCount -> Event next(First -> 3|C) 2017-12-27 15:11:51.970: refCount -> Event completed 2017-12-27 15:11:51.970: refCount -> isDisposed replay 确保观察者接收到同样的序列，即使是在 Observable 发出元素后才订阅，replay 操作符将 Observable 转换为可被连接的 Observable，并且这个可被连接的 Observable 将缓存最新的 n 个元素。当有新的观察者对它进行订阅时，它就把这些被缓存的元素发送给观察者。 RxSwift学习之旅 - share vs replay vs shareReplay eg: func replay() { let observable = getFirstObservable().replayAll() // let observable = getFirstObservable().replay(4) observable .debug(\"First\") .subscribe() .disposed(by: disposeBag) observable .connect() .disposed(by: disposeBag) delayTime(6) { observable .debug(\"replay\") .subscribe() .disposed(by: self.disposeBag) } } 输出如下： 2017-12-27 15:15:14.401: First -> subscribed 2017-12-27 15:15:15.403: First -> Event next(First -> 1|A) 2017-12-27 15:15:15.403: First -> Event next(First -> 1|B) 2017-12-27 15:15:15.403: First -> Event next(First -> 1|C) 2017-12-27 15:15:19.892: First -> Event next(First -> 2|A) 2017-12-27 15:15:19.892: First -> Event next(First -> 2|B) 2017-12-27 15:15:19.892: First -> Event next(First -> 2|C) 2017-12-27 15:15:20.999: Replay -> subscribed 2017-12-27 15:15:21.000: Replay -> Event next(First -> 1|A) 2017-12-27 15:15:21.000: Replay -> Event next(First -> 1|B) 2017-12-27 15:15:21.000: Replay -> Event next(First -> 1|C) 2017-12-27 15:15:21.000: Replay -> Event next(First -> 2|A) 2017-12-27 15:15:21.000: Replay -> Event next(First -> 2|B) 2017-12-27 15:15:21.000: Replay -> Event next(First -> 2|C) 2017-12-27 15:15:23.402: First -> Event next(First -> 3|A) 2017-12-27 15:15:23.403: Replay -> Event next(First -> 3|A) 2017-12-27 15:15:23.403: First -> Event next(First -> 3|B) 2017-12-27 15:15:23.403: Replay -> Event next(First -> 3|B) 2017-12-27 15:15:23.403: First -> Event next(First -> 3|C) 2017-12-27 15:15:23.403: Replay -> Event next(First -> 3|C) 2017-12-27 15:15:23.403: First -> Event completed 2017-12-27 15:15:23.403: First -> isDisposed 2017-12-27 15:15:23.403: Replay -> Event completed 2017-12-27 15:15:23.403: Replay -> isDisposed share 使观察者共享 Observable，不会对新增的观察者发送之前已经发送了的元素。 ⚠️注意：当订阅者从多个变成 0 的时候重置序列，否则不重置序列。 RxSwift学习之旅 - share vs replay vs shareReplay eg: func share() { let observable = getFirstObservable().share() observable .debug(\"First Subscribe\") .subscribe() .disposed(by: disposeBag) delayTime(7) { observable .debug(\"Second Subscribe\") .subscribe() .disposed(by: self.disposeBag) } delayTime(12) { print(\"====================订阅者总数变为了0====================\") observable .debug(\"Third Subscribe\") .subscribe() .disposed(by: self.disposeBag) } } 输出如下： 2017-12-27 16:14:10.869: First Subscribe -> subscribed 2017-12-27 16:14:11.871: First Subscribe -> Event next(First -> 1|A) 2017-12-27 16:14:11.871: First Subscribe -> Event next(First -> 1|B) 2017-12-27 16:14:11.871: First Subscribe -> Event next(First -> 1|C) 2017-12-27 16:14:15.871: First Subscribe -> Event next(First -> 2|A) 2017-12-27 16:14:15.871: First Subscribe -> Event next(First -> 2|B) 2017-12-27 16:14:15.871: First Subscribe -> Event next(First -> 2|C) 2017-12-27 16:14:17.871: Second Subscribe -> subscribed 2017-12-27 16:14:20.763: First Subscribe -> Event next(First -> 3|A) 2017-12-27 16:14:20.763: Second Subscribe -> Event next(First -> 3|A) 2017-12-27 16:14:20.764: First Subscribe -> Event next(First -> 3|B) 2017-12-27 16:14:20.764: Second Subscribe -> Event next(First -> 3|B) 2017-12-27 16:14:20.764: First Subscribe -> Event next(First -> 3|C) 2017-12-27 16:14:20.764: Second Subscribe -> Event next(First -> 3|C) 2017-12-27 16:14:20.764: First Subscribe -> Event completed 2017-12-27 16:14:20.764: First Subscribe -> isDisposed 2017-12-27 16:14:20.764: Second Subscribe -> Event completed 2017-12-27 16:14:20.764: Second Subscribe -> isDisposed ====================订阅者总数变为了0==================== 2017-12-27 16:14:24.066: Third Subscribe -> subscribed 2017-12-27 16:14:25.163: Third Subscribe -> Event next(First -> 1|A) 2017-12-27 16:14:25.163: Third Subscribe -> Event next(First -> 1|B) 2017-12-27 16:14:25.163: Third Subscribe -> Event next(First -> 1|C) 2017-12-27 16:14:29.066: Third Subscribe -> Event next(First -> 2|A) 2017-12-27 16:14:29.066: Third Subscribe -> Event next(First -> 2|B) 2017-12-27 16:14:29.066: Third Subscribe -> Event next(First -> 2|C) 2017-12-27 16:14:33.066: Third Subscribe -> Event next(First -> 3|A) 2017-12-27 16:14:33.066: Third Subscribe -> Event next(First -> 3|B) 2017-12-27 16:14:33.066: Third Subscribe -> Event next(First -> 3|C) 2017-12-27 16:14:33.066: Third Subscribe -> Event completed 2017-12-27 16:14:33.066: Third Subscribe -> isDisposed shareReplay @available(*, deprecated, message: \"Suggested replacement is share(replay: 1). In case old 3.x behavior of shareReplay is required please use share(replay: 1, scope: .forever) instead.\", renamed: \"share(replay:)\") 使观察者共享 Observable，观察者会立即收到最新的元素，即使这些元素是在订阅前产生的 shareReplay 操作符将使得观察者共享源 Observable，并且缓存最新的 n 个元素，将这些元素直接发送给新的观察者。 ⚠️注意：当订阅者从多个变成 0 的时候不会清空缓存不会重置序列，再次订阅直接返回 replay 的数目的元素。 RxSwift学习之旅 - share vs replay vs shareReplay func shareReplay() { let observable = getFirstObservable().share(replay: 2, scope: SubjectLifetimeScope.forever) observable .debug(\"Origin\") .subscribe() .disposed(by: disposeBag) delayTime(3) { observable .debug(\"shareReply\") .subscribe() .disposed(by: self.disposeBag) } } 输出如下： 2017-12-27 16:19:53.859: First Subscribe -> subscribed 2017-12-27 16:19:54.862: First Subscribe -> Event next(First -> 1|A) 2017-12-27 16:19:54.862: First Subscribe -> Event next(First -> 1|B) 2017-12-27 16:19:54.862: First Subscribe -> Event next(First -> 1|C) 2017-12-27 16:19:58.861: First Subscribe -> Event next(First -> 2|A) 2017-12-27 16:19:58.861: First Subscribe -> Event next(First -> 2|B) 2017-12-27 16:19:58.861: First Subscribe -> Event next(First -> 2|C) 2017-12-27 16:20:00.862: Second Subscribe -> subscribed 2017-12-27 16:20:00.863: Second Subscribe -> Event next(First -> 2|B) 2017-12-27 16:20:00.863: Second Subscribe -> Event next(First -> 2|C) 2017-12-27 16:20:02.861: First Subscribe -> Event next(First -> 3|A) 2017-12-27 16:20:02.861: Second Subscribe -> Event next(First -> 3|A) 2017-12-27 16:20:02.861: First Subscribe -> Event next(First -> 3|B) 2017-12-27 16:20:02.861: Second Subscribe -> Event next(First -> 3|B) 2017-12-27 16:20:02.861: First Subscribe -> Event next(First -> 3|C) 2017-12-27 16:20:02.861: Second Subscribe -> Event next(First -> 3|C) 2017-12-27 16:20:02.863: First Subscribe -> Event completed 2017-12-27 16:20:02.863: First Subscribe -> isDisposed 2017-12-27 16:20:02.864: Second Subscribe -> Event completed 2017-12-27 16:20:02.864: Second Subscribe -> isDisposed ====================订阅者总数变为了0==================== 2017-12-27 16:20:05.862: Third Subscribe -> subscribed 2017-12-27 16:20:05.862: Third Subscribe -> Event next(First -> 3|B) 2017-12-27 16:20:05.862: Third Subscribe -> Event next(First -> 3|C) 2017-12-27 16:20:05.862: Third Subscribe -> Event completed 2017-12-27 16:20:05.862: Third Subscribe -> isDisposed shareReplayLatestWhileConnected @available(*, deprecated, message: \"use share(replay: 1) instead\", renamed: \"share(replay:)\") 使观察者共享 Observable，观察者会立即收到最新的元素，即使这些元素是在订阅前产生的 shareReplayLatestWhileConnected 操作符将使得观察者共享源 Observable，并且缓存最新的 n 个元素，将这些元素直接发送给新的观察者。 ⚠️注意：当订阅者从多个变成 0 的时候清空缓存并且重置序列，否则不重置序列 RxSwift学习之旅 - share vs replay vs shareReplay eg: func shareReplayLatestWhileConnected() { // @available(*, deprecated, message: \"use share(replay: 1) instead\", renamed: \"share(replay:)\") let observable = getFirstObservable().share(replay: 2, scope: SubjectLifetimeScope.whileConnected) observable .debug(\"First Subscribe\") .subscribe() .disposed(by: disposeBag) delayTime(7) { observable .debug(\"Second Subscribe\") .subscribe() .disposed(by: self.disposeBag) } delayTime(12) { print(\"====================订阅者总数变为了0====================\") observable .debug(\"Third Subscribe\") .subscribe() .disposed(by: self.disposeBag) } } 输出如下： 2017-12-27 16:26:11.460: First Subscribe -> subscribed 2017-12-27 16:26:12.466: First Subscribe -> Event next(First -> 1|A) 2017-12-27 16:26:12.466: First Subscribe -> Event next(First -> 1|B) 2017-12-27 16:26:12.466: First Subscribe -> Event next(First -> 1|C) 2017-12-27 16:26:16.463: First Subscribe -> Event next(First -> 2|A) 2017-12-27 16:26:16.464: First Subscribe -> Event next(First -> 2|B) 2017-12-27 16:26:16.464: First Subscribe -> Event next(First -> 2|C) 2017-12-27 16:26:18.870: Second Subscribe -> subscribed 2017-12-27 16:26:18.871: Second Subscribe -> Event next(First -> 2|B) 2017-12-27 16:26:18.871: Second Subscribe -> Event next(First -> 2|C) 2017-12-27 16:26:20.463: First Subscribe -> Event next(First -> 3|A) 2017-12-27 16:26:20.463: Second Subscribe -> Event next(First -> 3|A) 2017-12-27 16:26:20.464: First Subscribe -> Event next(First -> 3|B) 2017-12-27 16:26:20.464: Second Subscribe -> Event next(First -> 3|B) 2017-12-27 16:26:20.464: First Subscribe -> Event next(First -> 3|C) 2017-12-27 16:26:20.464: Second Subscribe -> Event next(First -> 3|C) 2017-12-27 16:26:20.464: First Subscribe -> Event completed 2017-12-27 16:26:20.464: First Subscribe -> isDisposed 2017-12-27 16:26:20.464: Second Subscribe -> Event completed 2017-12-27 16:26:20.464: Second Subscribe -> isDisposed ====================订阅者总数变为了0==================== 2017-12-27 16:26:23.464: Third Subscribe -> subscribed 2017-12-27 16:26:24.552: Third Subscribe -> Event next(First -> 1|A) 2017-12-27 16:26:24.552: Third Subscribe -> Event next(First -> 1|B) 2017-12-27 16:26:24.552: Third Subscribe -> Event next(First -> 1|C) 2017-12-27 16:26:28.952: Third Subscribe -> Event next(First -> 2|A) 2017-12-27 16:26:28.952: Third Subscribe -> Event next(First -> 2|B) 2017-12-27 16:26:28.952: Third Subscribe -> Event next(First -> 2|C) 2017-12-27 16:26:32.464: Third Subscribe -> Event next(First -> 3|A) 2017-12-27 16:26:32.464: Third Subscribe -> Event next(First -> 3|B) 2017-12-27 16:26:32.464: Third Subscribe -> Event next(First -> 3|C) 2017-12-27 16:26:32.464: Third Subscribe -> Event completed 2017-12-27 16:26:32.464: Third Subscribe -> isDisposed "},"RxSwiftStudy/Operator/Time.html":{"url":"RxSwiftStudy/Operator/Time.html","title":"7.10 Time Operator","keywords":"","body":"Time Operator delay delay 操作符将修改一个 Observable，它会将 Observable 的所有元素都拖延一段设定好的时间， 然后才将它们发送出来。 ⚠️注意：是延迟元素的发出时间而不是延迟订阅或者创建 Observable 的时间 eg: func delay() { getFourthObservable() .delay(5, scheduler: MainScheduler.instance) .debug(\"delay\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 16:38:12.431: delay -> subscribed > Send onNext(\"0️⃣\") > Send onNext(\"1️⃣\") > Send onNext(\"2️⃣\") 2017-12-27 16:38:17.435: delay -> Event next(0️⃣) 2017-12-27 16:38:18.433: delay -> Event next(1️⃣) 2017-12-27 16:38:19.433: delay -> Event next(2️⃣) delaySubscription delaySubscription 操作符将在经过所设定的时间后，才真正的对 Observable 进行订阅操作。 ⚠️注意：是延迟延迟订阅时间，而不是元素的发出时间或者创建 Observable 的时间 func delaySubscription() { print(\"Create Observable Now\") getFourthObservable() .delaySubscription(5, scheduler: MainScheduler.instance) .debug(\"delaySubscription\") .subscribe() .disposed(by: disposeBag) } 输出如下： Create Observable Now 2017-12-27 16:42:49.984: delaySubscription -> subscribed > Send onNext(\"0️⃣\") 2017-12-27 16:42:54.989: delaySubscription -> Event next(0️⃣) > Send onNext(\"1️⃣\") 2017-12-27 16:42:56.086: delaySubscription -> Event next(1️⃣) > Send onNext(\"2️⃣\") 2017-12-27 16:42:57.179: delaySubscription -> Event next(2️⃣) defer 直到订阅发生，才创建 Observable，并且为每位订阅者创建全新的 Observable ⚠️注意：是延迟创建 Observable ，而不是延迟订阅或者延迟元素的发出时间 defer 操作符将等待观察者订阅它，才创建一个 Observable，它会通过一个构建函数为每一位订阅者创建新的 Observable。 ⚠️注意：看上去每位订阅者都是对同一个 Observable 产生订阅，实际上它们都获得了独立的序列。其实并不是像以前一样订阅同一个 Observable，实际为每个订阅者都创建了一个 Observable ，在一些情况下，直到订阅时才创建 Observable 是可以保证拿到的数据都是最新的。 eg: func `defer`() { let observable = Observable.deferred { [unowned self] () -> Observable in print(\"Observable is Create Now\") return self.getSecondObservable() } delayTime(2) { print(\"First Subscribe Now\") observable .debug(\"Test Defer: First Subscribe\") .subscribe() .disposed(by: self.disposeBag) } // 测试是否为每位订阅者都创建了 Observable delayTime(5) { print(\"Second Subscribe Now\") observable .debug(\"Test Defer: Second Subscribe\") .subscribe() .disposed(by: self.disposeBag) } } 输出如下： First Subscribe Now 2017-12-27 09:44:31.176: Test Defer: First Subscribe -> subscribed Observable is Create Now 2017-12-27 09:44:31.280: Test Defer: First Subscribe -> Event next(Second -> 1) Second Subscribe Now 2017-12-27 09:44:34.171: Test Defer: Second Subscribe -> subscribed Observable is Create Now 2017-12-27 09:44:34.279: Test Defer: Second Subscribe -> Event next(Second -> 1) 2017-12-27 09:44:35.280: Test Defer: First Subscribe -> Event next(Second -> 2) 2017-12-27 09:44:38.279: Test Defer: Second Subscribe -> Event next(Second -> 2) 2017-12-27 09:44:39.280: Test Defer: First Subscribe -> Event next(Second -> 3) 2017-12-27 09:44:39.280: Test Defer: First Subscribe -> Event completed 2017-12-27 09:44:39.280: Test Defer: First Subscribe -> isDisposed 2017-12-27 09:44:42.279: Test Defer: Second Subscribe -> Event next(Second -> 3) 2017-12-27 09:44:42.279: Test Defer: Second Subscribe -> Event completed 2017-12-27 09:44:42.280: Test Defer: Second Subscribe -> isDisposed interval 创建一个 Observable 每隔一段时间，发出一个索引数 interval 操作符将创建一个 Observable，它每隔一段设定的时间，发出一个索引数的元素。它将发出无数个元素。 eg: func interval() { let intervalQueue = DispatchQueue.init(label: \"ink.tbd.test.interval\") Observable .interval(1, scheduler: ConcurrentDispatchQueueScheduler.init(queue: intervalQueue)) .subscribe({ (e) in print(\"interval => \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下： interval => next(0) interval => next(1) interval => next(2) interval => next(3) interval => next(4) interval => next(5) interval => next(6) interval => next(7) ........... ........... timer 创建一个 Observable 在一段延时后，产生唯一的一个元素 timer 操作符将创建一个 Observable，它在经过设定的一段时间后，产生唯一的一个元素。 ⚠️注意：timer(_:period:scheduler:) 与 interval(_:scheduler:) 的区别 timer(_:period:scheduler:) 的实现： public static func timer(_ dueTime: RxTimeInterval, period: RxTimeInterval? = nil, scheduler: SchedulerType) -> Observable { return Timer( dueTime: dueTime, period: period, scheduler: scheduler ) } interval(_:scheduler:) 的实现： public static func interval(_ period: RxTimeInterval, scheduler: SchedulerType) -> Observable { return Timer(dueTime: period, period: period, scheduler: scheduler ) } eg: func timer() { // dueTime: 初始延时, period: 时间间隔, scheduler: 队列 let timerObservable = Observable.timer(5.0, period: 1, scheduler: MainScheduler.instance) timerObservable .debug(\"timer\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 09:57:16.075: timer -> subscribed 2017-12-27 09:57:21.077: timer -> Event next(0) 2017-12-27 09:57:22.076: timer -> Event next(1) 2017-12-27 09:57:23.077: timer -> Event next(2) 2017-12-27 09:57:24.077: timer -> Event next(3) 2017-12-27 09:57:25.077: timer -> Event next(4) 2017-12-27 09:57:26.077: timer -> Event next(5) 2017-12-27 09:57:27.077: timer -> Event next(6) 2017-12-27 09:57:28.076: timer -> Event next(7) 2017-12-27 09:57:29.076: timer -> Event next(8) 2017-12-27 09:57:30.076: timer -> Event next(9) 2017-12-27 09:57:31.075: timer -> Event next(10) ............ ............ timeout 如果源 Observable 在规定时间内没有发任何出元素，就产生一个超时的 error 事件 timer 操作符将使得序列发出一个 error 事件，只要 Observable 在一段时间内没有产生元素。 eg: func timeout() { let observable = Observable.never() observable .timeout(3, scheduler: MainScheduler.instance) .debug(\"timeout\") .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 16:44:32.898: timeout -> subscribed 2017-12-27 16:44:35.899: timeout -> Event error(Sequence timeout.) Unhandled error happened: Sequence timeout. subscription called from: 0 RxSwift 0x000000010b9db58c _T07RxSwift14ObservableTypePAAE9subscribeAA10Disposable_py1EQzcSg6onNext_ys5Error_pcSg0gI0yycSg0G9CompletedAM0G8DisposedtF + 780 1 RxSwiftExample 0x000000010b277bae _T011RxSwiftExample8OperatorC7timeoutyyF + 1150 2 RxSwiftExample 0x000000010b277e04 _T011RxSwiftExample8OperatorC7timeoutyyFTo + 36 3 RxSwiftExample 0x000000010b2ac771 _T011RxSwiftExample27OperatorTableViewControllerC11viewDidLoadyyFy10Foundation9IndexPathVcfU1_ + 897 4 RxSwiftExample 0x000000010b2ac8a7 _T011RxSwiftExample27OperatorTableViewControllerC11viewDidLoadyyFy10Foundation9IndexPathVcfU1_TA + 103 5 RxSwiftExample 0x000000010b26cdc0 _T010Foundation9IndexPathVIxx_ACIxi_TR + 48 6 RxSwiftExample 0x000000010b2ac932 _T010Foundation9IndexPathVIxx_ACIxi_TRTA + 66 7 RxSwift 0x000000010b9dbd35 _T07RxSwift14ObservableTypePAAE9subscribeAA10Disposable_py1EQzcSg6onNext_ys5Error_pcSg0gI0yycSg0G9CompletedAM0G8DisposedtFyAA5EventOyAGGcfU_ + 885 8 RxSwift 0x000000010b9dc28a _T07RxSwift14ObservableTypePAAE9subscribeAA10Disposable_py1EQzcSg6onNext_ys5Error_pcSg0gI0yycSg0G9CompletedAM0G8DisposedtFyAA5EventOyAGGcfU_TA + 282 9 RxSwift 0x000000010b911998 _T07RxSwift17AnonymousObserverC6onCoreyAA5EventOyxGF + 408 10 RxSwift 0x000000010b9e3026 _T07RxSwift12ObserverBaseC2onyAA5EventOyxGF + 742 11 RxSwift 0x000000010b9e35be _T07RxSwift12ObserverBaseCyxGAA0C4TypeAAlAaEP2onyAA5EventOy1EQzGFTW + 62 12 RxSwift 0x000000010b912c93 _T0TA + 115 13 RxSwift 0x000000010b91d3a7 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTR + 23 14 RxSwift 0x000000010ba2fbc6 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTRTA.47 + 118 15 RxSwift 0x000000010b91d770 _T07RxSwift5EventOyxGytIxir_ADIxi_lTR + 16 16 RxSwift 0x000000010b91f332 _T07RxSwift5EventOyxGytIxir_ADIxi_lTRTA.18 + 82 17 RxSwift 0x000000010b91e564 _T07RxSwift8dispatchyAA3BagVyyAA5EventOyxGcG_AGtlF + 900 18 RxSwift 0x000000010ba2992e _T07RxSwift36ShareReplay1WhileConnectedConnection33_E9FE621655D67A613BF2FC2D9B3041FCLLC2onyAA5EventOyxGF + 1230 19 RxSwift 0x000000010ba2baeb _T07RxSwift36ShareReplay1WhileConnectedConnection33_E9FE621655D67A613BF2FC2D9B3041FCLLCyxGAA12ObserverTypeAAlAaFP2onyAA5EventOy1EQzGFTW + 43 20 RxSwift 0x000000010ba37bcc _T07RxSwift4SinkC9forwardOnyAA5EventOy1EQzGF + 780 21 RxSwift 0x000000010b92fff7 _T07RxSwift9CatchSink33_7E15DB08AB19A7B882D5C92A393C6F6DLLC2onyAA5EventOy1EQzGF + 823 22 RxSwift 0x000000010b930a5b _T07RxSwift9CatchSink33_7E15DB08AB19A7B882D5C92A393C6F6DLLCyxGAA12ObserverTypeA2aFRzlAaFP2onyAA5EventOy1EQzGFTW + 43 23 RxSwift 0x000000010b9e0f11 _T07RxSwift32ObserveOnSerialDispatchQueueSink33_277A93ABA8477198C125F3F26B2D4B62LLCADyxGAA0efG9SchedulerC9scheduler_x8observerAA10Cancelable_p6canceltcfcAA10Disposable_pAE4sink_AA5EventOy1EQzG5eventtcfU_ + 833 24 RxSwift 0x000000010b9e2579 _T07RxSwift32ObserveOnSerialDispatchQueueSink33_277A93ABA8477198C125F3F26B2D4B62LLCADyxGAA0efG9SchedulerC9scheduler_x8observerAA10Cancelable_p6canceltcfcAA10Disposable_pAE4sink_AA5EventOy1EQzG5eventtcfU_TA + 9 25 RxSwift 0x000000010b9e17d9 _T07RxSwift32ObserveOnSerialDispatchQueueSink33_277A93ABA8477198C125F3F26B2D4B62LLCyxGAA5EventOy1EQzGAA10Disposable_pIxxir_AE_AJtAaK_pIxir_AA12ObserverTypeRzlTR + 137 26 RxSwift 0x000000010b9e2786 _T07RxSwift32ObserveOnSerialDispatchQueueSink33_277A93ABA8477198C125F3F26B2D4B62LLCyxGAA5EventOy1EQzGAA10Disposable_pIxxir_AE_AJtAaK_pIxir_AA12ObserverTypeRzlTRTA + 102 27 RxSwift 0x000000010b9ba564 _T07RxSwift13MainSchedulerC16scheduleInternalAA10Disposable_px_AaE_pxc6actiontlF + 484 28 RxSwift 0x000000010ba26a4d _T07RxSwift28SerialDispatchQueueSchedulerC8scheduleAA10Disposable_px_AaE_pxc6actiontlF + 173 29 RxSwift 0x000000010b9e16cc _T07RxSwift32ObserveOnSerialDispatchQueueSink33_277A93ABA8477198C125F3F26B2D4B62LLC6onCoreyAA5EventOy1EQzGF + 1148 30 RxSwift 0x000000010b9e3026 _T07RxSwift12ObserverBaseC2onyAA5EventOyxGF + 742 31 RxSwift 0x000000010b9e35be _T07RxSwift12ObserverBaseCyxGAA0C4TypeAAlAaEP2onyAA5EventOy1EQzGFTW + 62 32 RxSwift 0x000000010ba37bcc _T07RxSwift4SinkC9forwardOnyAA5EventOy1EQzGF + 780 33 RxSwift 0x000000010ba420e0 _T07RxSwift15SubscribeOnSink33_B44C3DD7F62EF81799E6347E59A266A2LLC2onyAA5EventOy1EQzGF + 400 34 RxSwift 0x000000010ba42e0b _T07RxSwift15SubscribeOnSink33_B44C3DD7F62EF81799E6347E59A266A2LLCyxq_GAA12ObserverTypeA2A010ObservableP0RzAaFR_1EQy_AHRtzr0_lAaFP2onyAA5EventOyAHQzGFTW + 43 35 RxSwift 0x000000010ba37bcc _T07RxSwift4SinkC9forwardOnyAA5EventOy1EQzGF + 780 36 RxSwift 0x000000010b9bb695 _T07RxSwift7MapSink33_5428EFA9A9B0C0340021B871D2E5AC01LLC2onyAA5EventOyxGF + 1093 37 RxSwift 0x000000010b9bbbeb _T07RxSwift7MapSink33_5428EFA9A9B0C0340021B871D2E5AC01LLCyxq_GAA12ObserverTypeA2aFR_r0_lAaFP2onyAA5EventOy1EQzGFTW + 43 38 RxSwift 0x000000010ba37bcc _T07RxSwift4SinkC9forwardOnyAA5EventOy1EQzGF + 780 39 RxSwift 0x000000010ba420e0 _T07RxSwift15SubscribeOnSink33_B44C3DD7F62EF81799E6347E59A266A2LLC2onyAA5EventOy1EQzGF + 400 40 RxSwift 0x000000010ba42e0b _T07RxSwift15SubscribeOnSink33_B44C3DD7F62EF81799E6347E59A266A2LLCyxq_GAA12ObserverTypeA2A010ObservableP0RzAaFR_1EQy_AHRtzr0_lAaFP2onyAA5EventOyAHQzGFTW + 43 41 RxSwift 0x000000010b912c93 _T0TA + 115 42 RxSwift 0x000000010b91d3a7 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTR + 23 43 RxSwift 0x000000010ba2fa36 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTRTA + 118 44 RxSwift 0x000000010b91d770 _T07RxSwift5EventOyxGytIxir_ADIxi_lTR + 16 45 RxSwift 0x000000010b91f332 _T07RxSwift5EventOyxGytIxir_ADIxi_lTRTA.18 + 82 46 RxSwift 0x000000010b91e564 _T07RxSwift8dispatchyAA3BagVyyAA5EventOyxGcG_AGtlF + 900 47 RxSwift 0x000000010ba2ceee _T07RxSwift29ShareWhileConnectedConnection33_E9FE621655D67A613BF2FC2D9B3041FCLLC2onyAA5EventOyxGF + 1230 48 RxSwift 0x000000010ba2eabb _T07RxSwift29ShareWhileConnectedConnection33_E9FE621655D67A613BF2FC2D9B3041FCLLCyxGAA12ObserverTypeAAlAaFP2onyAA5EventOy1EQzGFTW + 43 49 RxSwift 0x000000010ba37bcc _T07RxSwift4SinkC9forwardOnyAA5EventOy1EQzGF + 780 50 RxSwift 0x000000010b9a0dfb _T07RxSwift6DoSink33_51F9E615740E91B2E920965FFBB1EED3LLC2onyAA5EventOy1EQzGF + 843 51 RxSwift 0x000000010b9a14eb _T07RxSwift6DoSink33_51F9E615740E91B2E920965FFBB1EED3LLCyxGAA12ObserverTypeA2aFRzlAaFP2onyAA5EventOy1EQzGFTW + 43 52 RxSwift 0x000000010b912c93 _T0TA + 115 53 RxSwift 0x000000010b91d3a7 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTR + 23 54 RxSwift 0x000000010b9f7396 _T07RxSwift5EventOyxGIxi_ADytIxir_1EQyd__RszAA12ObserverTypeRd__r__lTRTA + 118 55 RxSwift 0x000000010b91d770 _T07RxSwift5EventOyxGytIxir_ADIxi_lTR + 16 56 RxSwift 0x000000010b91f332 _T07RxSwift5EventOyxGytIxir_ADIxi_lTRTA.18 + 82 57 RxSwift 0x000000010b91e564 _T07RxSwift8dispatchyAA3BagVyyAA5EventOyxGcG_AGtlF + 900 58 RxSwift 0x000000010b9f51ca _T07RxSwift14PublishSubjectC2onyAA5EventOyxGF + 1018 59 RxCocoa 0x000000010b6a6d91 _T07RxSwift14PublishSubjectC2onyAA5EventOyxGFTA + 17 60 RxCocoa 0x000000010b6a646d _T07RxSwift5EventOySayypGGIxi_AEIxx_TR + 29 61 RxCocoa 0x000000010b6a6d6e _T07RxSwift5EventOySayypGGIxi_AEIxx_TRTA + 78 62 RxCocoa 0x000000010b6a45eb _T07RxCocoa13DelegateProxyC14_methodInvokedy10ObjectiveC8SelectorV_SayypG13withArgumentstF + 283 63 RxCocoa 0x000000010b6a4664 _T07RxCocoa13DelegateProxyC14_methodInvokedy10ObjectiveC8SelectorV_SayypG13withArgumentstFTo + 84 64 RxCocoa 0x000000010b675588 -[_RXDelegateProxy forwardInvocation:] + 536 65 CoreFoundation 0x000000010f91bcd8 ___forwarding___ + 760 66 CoreFoundation 0x000000010f91b958 _CF_forwarding_prep_0 + 120 67 UIKit 0x000000010cd43839 -[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:] + 1810 68 UIKit 0x000000010cd43a54 -[UITableView _userSelectRowAtPendingSelectionIndexPath:] + 344 69 UIKit 0x000000010cc0cd59 _runAfterCACommitDeferredBlocks + 318 70 UIKit 0x000000010cbfbbb1 _cleanUpAfterCAFlushAndRunDeferredBlocks + 280 71 UIKit 0x000000010cc2b0e0 _afterCACommitHandler + 137 72 CoreFoundation 0x000000010f93bc07 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23 73 CoreFoundation 0x000000010f93bb5e __CFRunLoopDoObservers + 430 74 CoreFoundation 0x000000010f920124 __CFRunLoopRun + 1572 75 CoreFoundation 0x000000010f91f889 CFRunLoopRunSpecific + 409 76 GraphicsServices 0x000000011504a9c6 GSEventRunModal + 62 77 UIKit 0x000000010cc015d6 UIApplicationMain + 159 78 RxSwiftExample 0x000000010b28d597 main + 55 79 libdyld.dylib 0x00000001111f6d81 start + 1 80 ??? 0x0000000000000001 0x0 + 1 2017-12-27 16:44:35.902: timeout -> isDisposed "},"RxSwiftStudy/Operator/Scheduler.html":{"url":"RxSwiftStudy/Operator/Scheduler.html","title":"7.11 Scheduler Operator","keywords":"","body":"Scheduler Operator observeOn https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/observeOn.html 指定 Observable 在哪个 Scheduler 发出通知 ReactiveX 使用 Scheduler 来让 Observable 支持多线程。你可以使用 observeOn 操作符，来指示 Observable 在哪个 Scheduler 发出通知。 ⚠️注意：一旦产生了 onError 事件， observeOn 操作符将立即转发。他不会等待 onError 之前的事件全部被收到。这意味着 onError 事件可能会跳过一些元素提前发送出去。 subscribeOn 操作符非常相似。它指示 Observable 在哪个 Scheduler 发出执行。 默认情况下，Observable 创建，应用操作符以及发出通知都会在 Subscribe 方法调用的 Scheduler 执行。subscribeOn 操作符将改变这种行为，它会指定一个不同的 Scheduler 来让 Observable 执行，observeOn 操作符将指定一个不同的 Scheduler 来让 Observable 通知观察者。 subscribeOn 操作符指定 Observable 在哪个 Scheduler 开始执行，无论它处于链的那个位置。 另一方面 observeOn 将决定后面的方法在哪个 Scheduler 运行。因此，你可能会多次调用 observeOn 来决定某些操作符在哪个线程运行。 eg: func observeOn() { let observable = Observable.of(1, 2, 3, 4, 5) let observeQueue = DispatchQueue.init(label: \"ink.tbd.test.observeQueue\") observable .observeOn(ConcurrentDispatchQueueScheduler.init(queue: observeQueue)) .subscribe({ (e) in print(\"observeOn: \\(getCurrentQueueName()); ==> \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下： observeOn: ink.tbd.test.observeQueue; ==> next(1) observeOn: ink.tbd.test.observeQueue; ==> next(2) observeOn: ink.tbd.test.observeQueue; ==> next(3) observeOn: ink.tbd.test.observeQueue; ==> next(4) observeOn: ink.tbd.test.observeQueue; ==> next(5) observeOn: ink.tbd.test.observeQueue; ==> completed subscribeOn https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/subscribeOn.html 指定 Observable 在哪个 Scheduler 执行 ReactiveX 使用 Scheduler 来让 Observable 支持多线程。你可以使用 subscribeOn 操作符，来指示 Observable 在哪个 Scheduler 执行。 observeOn 操作符非常相似。它指示 Observable 在哪个 Scheduler 发出通知。 默认情况下，Observable 创建，应用操作符以及发出通知都会在 Subscribe 方法调用的 Scheduler 执行。subscribeOn 操作符将改变这种行为，它会指定一个不同的 Scheduler 来让 Observable 执行，observeOn 操作符将指定一个不同的 Scheduler 来让 Observable 通知观察者。 subscribeOn 操作符指定 Observable 在那个 Scheduler 开始执行，无论它处于链的那个位置。 另一方面 observeOn 将决定后面的方法在哪个 Scheduler 运行。因此，你可能会多次调用 observeOn 来决定某些操作符在哪个线程运行。 eg: func subscribeOn() { let observable = Observable.of(1, 2, 3, 4, 5) let subscribeQueue = DispatchQueue.init(label: \"ink.tbd.test.subscribeQueue\") observable .subscribeOn(ConcurrentDispatchQueueScheduler.init(queue: subscribeQueue)) .subscribe({ (e) in print(\"subscribeOn: \\(getCurrentQueueName()); ==> \\(e.debugDescription)\") }) .disposed(by: disposeBag) } 输出如下： subscribeOn: ink.tbd.test.subscribeQueue; ==> next(1) subscribeOn: ink.tbd.test.subscribeQueue; ==> next(2) subscribeOn: ink.tbd.test.subscribeQueue; ==> next(3) subscribeOn: ink.tbd.test.subscribeQueue; ==> next(4) subscribeOn: ink.tbd.test.subscribeQueue; ==> next(5) subscribeOn: ink.tbd.test.subscribeQueue; ==> completed "},"RxSwiftStudy/Operator/Materialize.html":{"url":"RxSwiftStudy/Operator/Materialize.html","title":"7.12 Materialize Operator","keywords":"","body":"Materialize Operator materialize 通常，一个有限的 Observable 将产生零个或者多个 onNext 事件，然后产生一个 onCompleted 或者 onError 事件。 materialize 操作符将 Observable 产生的这些事件全部转换成元素，然后发送出来。 eg: func materialize() { getErrorObservable() .materialize() .subscribe({ (e) in print(e) }) .disposed(by: disposeBag) } 输出如下： next(next(1️⃣)) next(next(2️⃣)) next(error(TError(errorCode: 10, errorString: \"Test\", errorData: nil))) completed dematerialize dematerialize 操作符将 materialize 转换后的元素还原 eg: func dematerialize() { let materializeObservable = getErrorObservable().materialize() materializeObservable .dematerialize() .subscribe({ (e) in print(e) }) .disposed(by: disposeBag) } 输出如下： next(1️⃣) next(2️⃣) error(TError(errorCode: 10, errorString: \"Test\", errorData: nil)) "},"RxSwiftStudy/Operator/Using.html":{"url":"RxSwiftStudy/Operator/Using.html","title":"7.13 Using Operator","keywords":"","body":"Using Operator Using 创建一个可被清除的资源(即遵守Disposable协议)，它和 Observable 具有相同的寿命 通过使用 using 操作符创建 Observable 时，同时创建一个可被清除的资源，一旦 Observable 终止了，那么这个资源就会被清除掉了(即调用了该资源的dispose()方法)。 eg: func using() { class DisposableResource: Disposable { var values: [Int] = [] var isDisposed: Bool = false func dispose() { self.values = [] self.isDisposed = true print(\"!!!DisposableResource is Disposed!!!\") } init(with values: [Int]) { self.values = values } } let observable = Observable.using({ () -> DisposableResource in return DisposableResource.init(with: [1, 2, 3, 4]) }, observableFactory: { (resource) -> Observable in if resource.isDisposed { return Observable.from([]) } else { return Observable.from(resource.values) } }) observable .debug() .subscribe() .disposed(by: disposeBag) } 输出如下： 2017-12-27 17:06:35.757: Operator+Using.swift:43 (using()) -> subscribed 2017-12-27 17:06:35.759: Operator+Using.swift:43 (using()) -> Event next(1) 2017-12-27 17:06:35.759: Operator+Using.swift:43 (using()) -> Event next(2) 2017-12-27 17:06:35.759: Operator+Using.swift:43 (using()) -> Event next(3) 2017-12-27 17:06:35.759: Operator+Using.swift:43 (using()) -> Event next(4) 2017-12-27 17:06:35.759: Operator+Using.swift:43 (using()) -> Event completed 2017-12-27 17:06:35.759: Operator+Using.swift:43 (using()) -> isDisposed !!!DisposableResource is Disposed!!! "},"RxSwiftStudy/8.其他相关资料.html":{"url":"RxSwiftStudy/8.其他相关资料.html","title":"8. 其他相关资料","keywords":"","body":"其他相关资料 RxSwift 常用架构 MVVM RxFeedback ReactorKit RxSwift 生态系统 RxSwiftCommunity Github RxCocoa: Cocoa库扩展 RxDataSources: UITableView 和 UICollectionView 数据源 RxAlamofire: 网络请求 RxRealm: Realm 数据库 RxCoreData: CoreData 数据库 RxGesture: 页面手势 RxMKMapView: 地图 RxCoreMotion: 陀螺仪 RxMediaPicker: 图片选择器 Action: 行为 RxWebKit: WebView RxEventHub: 全局通知 RxSwiftExt: 添加一些有用的操作符 "}}